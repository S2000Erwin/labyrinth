defpackage sdl2 :
   import core
   import collections

val SDL_INIT_TIMER =          0x00000001
val SDL_INIT_AUDIO =         0x00000010
val SDL_INIT_VIDEO =         0x00000020  ;/**< SDL_INIT_VIDEO implies SDL_INIT_EVENTS */
val SDL_INIT_JOYSTICK =       0x00000200  ;/**< SDL_INIT_JOYSTICK implies SDL_INIT_EVENTS */
val SDL_INIT_HAPTIC =        0x00001000
val SDL_INIT_GAMECONTROLLER =  0x00002000  ;/**< SDL_INIT_GAMECONTROLLER implies SDL_INIT_JOYSTICK */
val SDL_INIT_EVENTS =         0x00004000
val SDL_INIT_SENSOR =        0x00008000

val SDL_INIT_EVERYTHING = SDL_INIT_TIMER | SDL_INIT_AUDIO | SDL_INIT_VIDEO | SDL_INIT_EVENTS | SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_GAMECONTROLLER | SDL_INIT_SENSOR 

val SDL_WINDOWPOS_UNDEFINED : Int = 0x1fff0000
val SDL_WINDOWPOS_CENTERED : Int = 0x2fff0000

val IMG_INIT_JPG : Int = 1
val IMG_INIT_PNG : Int = 2
val IMG_INIT_TIF : Int = 4
val IMG_INIT_WEBP : Int = 8

val SDL_QUIT = 0x100

val SDL_WINDOW_FULLSCREEN = 0x00000001,         ;/**< fullscreen window */
val SDL_WINDOW_OPENGL = 0x00000002,             ;/**< window usable with OpenGL context */
val SDL_WINDOW_SHOWN = 0x00000004,              ;/**< window is visible */
val SDL_WINDOW_HIDDEN = 0x00000008,             ;/**< window is not visible */
val SDL_WINDOW_BORDERLESS = 0x00000010,         ;/**< no window decoration */
val SDL_WINDOW_RESIZABLE = 0x00000020,          ;/**< window can be resized */
val SDL_WINDOW_MINIMIZED = 0x00000040,          ;/**< window is minimized */
val SDL_WINDOW_MAXIMIZED = 0x00000080,          ;/**< window is maximized */
val SDL_WINDOW_MOUSE_GRABBED = 0x00000100,      ;/**< window has grabbed mouse input */
val SDL_WINDOW_INPUT_FOCUS = 0x00000200,        ;/**< window has input focus */
val SDL_WINDOW_MOUSE_FOCUS = 0x00000400,        ;/**< window has mouse focus */
val SDL_WINDOW_FULLSCREEN_DESKTOP = ( SDL_WINDOW_FULLSCREEN | 0x00001000 ),
val SDL_WINDOW_FOREIGN = 0x00000800,            ;/**< window not created by SDL */
val SDL_WINDOW_ALLOW_HIGHDPI = 0x00002000,      ;/**< window should be created in high-DPI mode if supported.
                                                ;     On macOS NSHighResolutionCapable must be set true in the
                                                ;     application's Info.plist for this to have any effect. */
val SDL_WINDOW_MOUSE_CAPTURE    = 0x00004000,   ;/**< window has mouse captured (unrelated to MOUSE_GRABBED) */
val SDL_WINDOW_ALWAYS_ON_TOP    = 0x00008000,   ;/**< window should always be above others */
val SDL_WINDOW_SKIP_TASKBAR     = 0x00010000,   ;/**< window should not be added to the taskbar */
val SDL_WINDOW_UTILITY          = 0x00020000,   ;/**< window should be treated as a utility window */
val SDL_WINDOW_TOOLTIP          = 0x00040000,   ;/**< window should be treated as a tooltip */
val SDL_WINDOW_POPUP_MENU       = 0x00080000,   ;/**< window should be treated as a popup menu */
val SDL_WINDOW_KEYBOARD_GRABBED = 0x00100000,   ;/**< window has grabbed keyboard input */
val SDL_WINDOW_VULKAN           = 0x10000000,   ;/**< window usable for Vulkan surface */
val SDL_WINDOW_METAL            = 0x20000000,   ;/**< window usable for Metal view */

lostanza deftype SDL_version :
   major: byte
   minor: byte
   patch: byte

lostanza deftype SDL_Rect :
   x: int
   y: int
   w: int
   h: int

lostanza deftype SDL_Event :
   type: int
   timestamp : int
   window-id : int
   event :  int
   data1 : long
   data2 : long

lostanza defn SDL_Rect (x:ref<Int>, y:ref<Int>, w:ref<Int>, h:ref<Int>) -> ref<SDL_Rect> :
   return new SDL_Rect{x.value, y.value, w.value, h.value}

lostanza defn SDL_RGBA (r:ref<Byte>, g:ref<Byte>, b:ref<Byte>, a:ref<Byte>) -> ref<Int> :
   return new Int{a.value << 24 + r.value << 16 + g.value << 8 + b.value}

extern SDL_GetVersion: (ptr<SDL_version>) -> int
extern SDL_Init: int -> int
extern SDL_CreateWindow: (ptr<byte>, int, int, int, int, int) -> long
extern SDL_GetWindowSurface: (long) -> long
extern SDL_FreeSurface: (long) -> int
extern SDL_ConvertSurface: (long, long, int) -> long
extern SDL_UpperBlit: (long, ptr<SDL_Rect>, long, ptr<SDL_Rect>) -> int
extern SDL_UpperBlitScaled: (long, ptr<SDL_Rect>, long, ptr<SDL_Rect>) -> int
extern SDL_FillRect: (long, ptr<SDL_Rect>, int) -> int
extern SDL_UpdateWindowSurface: (long) -> int
extern IMG_Init: int -> int
extern IMG_Quit: () -> int
extern IMG_Load: (ptr<byte>) -> long
extern SDL_PollEvent: (ptr<SDL_Event>) -> int


lostanza defn call-SDL_version () -> ref<Int> :
   val v = new SDL_version{0Y, 0Y, 0Y}
   call-c SDL_GetVersion(addr!([v])) 
   return new Int{v.major}

lostanza defn call-SDL_Init (a:ref<Int>) -> ref<Int> :
   val result = call-c SDL_Init(a.value)
   return new Int{result}

lostanza defn call-SDL_CreateWindow (name : ref<String>, width : ref<Int>, height : ref<Int>) -> ref<Long> :
   val p = call-c SDL_CreateWindow(
                           addr!(name.chars), 
                           SDL_WINDOWPOS_CENTERED.value, SDL_WINDOWPOS_CENTERED.value, 
                           width.value, height.value, 
                           SDL_WINDOW_RESIZABLE.value)
   return new Long{p}

lostanza defn call-SDL_GetWindowSurface (p : ref<Long>) -> ref<Long> :
   val ws = call-c SDL_GetWindowSurface(p.value)
   return new Long{ws}

lostanza defn call-SDL_FillRect (p : ref<Long>, rect : ref<SDL_Rect|False>, argb : ref<Int>) -> ref<Int> :
   var pRect : ptr<SDL_Rect>
   match(rect) :
      (rect : ref<SDL_Rect>) : pRect = addr!([rect])
      (rect) : pRect = null as ptr<SDL_Rect>
   val result = call-c SDL_FillRect(p.value, pRect, argb.value)
   return new Int{result}

lostanza defn call-SDL_UpdateWindowSurface (window : ref<Long>) -> ref<Int> :
   val result = call-c SDL_UpdateWindowSurface(window.value)
   return new Int{result}

lostanza defn call-SDL_FreeSurface (surface : ref<Long> ) -> ref<False> :
   call-c SDL_FreeSurface(surface.value)
   return false

lostanza defn call-SDL_ConvertSurface (surface : ref<Long>, dst_surface : ref<Long>) -> ref<Long> :
   ; NOTE!!!!!! this function is not the same as that in SDL
   ; the trick is
   ; * format is right after Unit32 flags
   ; dst_surface.value + 8 points to the *format pointer
   ; [dst_surface.value+8] is the value we want
   ; 
   val ad = dst_surface.value + 8     ; skip the flags (internal). Assume 64-bit. Change this to 4 in 32-bit
   val p : ptr<long> = ad as ptr<long>
   val result = call-c SDL_ConvertSurface(surface.value, [p], 0)
   return new Long{result}

lostanza defn pRect (rect : ref<SDL_Rect|False>) -> ptr<SDL_Rect> :
   match(rect) :
      (rect : ref<SDL_Rect>) : return addr!([rect])
      (rect) : return null as ptr<SDL_Rect>
   
; See this issue: https://github.com/BindBC/bindbc-sdl/issues/15
; Use SDL_UpperBlit and SDL_UpperBlitScaled
lostanza defn call-SDL_BlitSurface (src : ref<Long>, src-rect : ref<SDL_Rect|False>, 
                                    dst : ref<Long>, dst-rect : ref<SDL_Rect|False>) -> ref<True|False> :
   val p-src-rect = pRect(src-rect)
   val p-dst-rect = pRect(dst-rect)
   val result = call-c SDL_UpperBlit( src.value, p-src-rect, dst.value, p-dst-rect )
   if result == 0 :
      return true
   else :
      return false

lostanza defn call-SDL_BlitScaled  (src : ref<Long>, src-rect : ref<SDL_Rect|False>, 
                                    dst : ref<Long>, dst-rect : ref<SDL_Rect|False>) -> ref<True|False> :
   val p-src-rect = pRect(src-rect)
   val p-dst-rect = pRect(dst-rect)
   val result = call-c SDL_UpperBlitScaled( src.value, p-src-rect, dst.value, p-dst-rect )
   if result == 0 :
      return true
   else :
      return false

lostanza defn call-IMG_Init (flags : ref<Int>) -> ref<True|False> :
   val result = call-c IMG_Init(flags.value)
   if ( result & flags.value ) == flags.value :
      return true
   else :
      return false

lostanza defn call-IMG_Quit () -> ref<False> :
   call-c IMG_Quit()
   return false

lostanza defn call-IMG_Load (filename : ref<String>) -> ref<Long> :
   val result = call-c IMG_Load(addr!(filename.chars))
   return new Long{result} 

lostanza defn call-SDL_PollEvent () -> ref<SDL_Event|False> :
   val e = new SDL_Event{0, 0, 0, 0, 0L, 0L}
   val result = call-c SDL_PollEvent(addr!([e]))
   if result != 0 :
      return new SDL_Event{e.type, e.timestamp e.window-id e.event e.data1 e.data2}
   else:
      return false
   
; ================
; pulbic interface
; ================
public defstruct SDL-rect :
   x : Int
   y : Int
   w : Int
   h : Int

public defn sdl-create-window (name : String, width : Int, height : Int) -> [Long Long] :
   val result = call-SDL_Init(SDL_INIT_EVERYTHING)
   println("SDL_Init:%_" % [result])
   val img_result = call-IMG_Init(IMG_INIT_JPG|IMG_INIT_PNG)
   println("IMG_Init: %_" % [img_result])
   val window = call-SDL_CreateWindow(name, width, height)
   val win-surface = call-SDL_GetWindowSurface(window)
   [window, win-surface]

public defn sdl-load-image (name : String, win-surface : Long ) -> Long :
   val img-surface = call-IMG_Load(name)
   if img-surface != 0L :
      val opt-surface = call-SDL_ConvertSurface(img-surface, win-surface)
      call-SDL_FreeSurface(img-surface)
      opt-surface
   else :
      0L

public defn sdl-overlay (src : Long, src-rect : SDL-rect|False, dst : Long, dst-rect : SDL-rect|False) :
   val lo-src-rect : SDL_Rect|False = 
      SDL_Rect(x(src-rect as SDL-rect), y(src-rect as SDL-rect), w(src-rect as SDL-rect), h(src-rect as SDL-rect)) when src-rect is-not False else false
   val lo-dst-rect : SDL_Rect|False = 
      SDL_Rect(x(dst-rect as SDL-rect), y(dst-rect as SDL-rect), w(dst-rect as SDL-rect), h(dst-rect as SDL-rect)) when dst-rect is-not False else false
   call-SDL_BlitScaled(src, lo-src-rect, dst, lo-dst-rect)
   
public defn sdl-update (window : Long):
   call-SDL_UpdateWindowSurface(window)

defstruct sdl-event :
   type : Int

; return True if we need to quit
public defn sdl-event-loop () -> Tuple<SDL_Event>:
   val v = Vector<SDL_Event>()
   var counter = 0
   label<False> break :
      while true :
         val e = call-SDL_PollEvent()
         match(e):
            (e : False) :
               break(false)
            (e : SDL_Event) :
               if counter >= 100:
                  break(false)
               add(v, e)
               counter = counter + 1
   to-tuple(v)
         

public defn test-sdl2 () :
   println("Calling SDL_Init()")
   println(call-SDL_version())
   val result = call-SDL_Init(SDL_INIT_VIDEO)
   println("Done calling SDL_Init(): %_" % [result])
   val p = call-SDL_CreateWindow("Labyrinth", 640, 480)
   println("SDL_CreateWindow: %_" % [p])
   val ws = call-SDL_GetWindowSurface(p)
   println("SDL_GetWindowSurface: %_" % [ws])
   val rect = SDL_Rect(50,50,50,50)
   val red = SDL_RGBA(255Y, 0Y, 0Y, 255Y)
   val fr = call-SDL_FillRect(ws, false, red)
   val green = SDL_RGBA(0Y, 255Y, 0Y, 255Y)
   call-SDL_FillRect(ws, rect, green)
   val up = call-SDL_UpdateWindowSurface(p)
   println("SDL_UpdateWindowSurface:%_ %_" % [fr up])
   val ii = call-IMG_Init(IMG_INIT_JPG|IMG_INIT_PNG)
   if ii :
      val img_surface = call-IMG_Load("vassalimages/LabyrinthSplash.jpg")
      println("IMG_Load:%_" %[img_surface])
      if img_surface != 0 :
         val opt_surface = call-SDL_ConvertSurface(img_surface, ws)
         println("SDL_ConvertSurface:%_" % [opt_surface])
         call-SDL_FreeSurface(img_surface)
         ; start blitting
         val opt-rect = SDL_Rect(100, 100, 400, 600)
         val bs = call-SDL_BlitSurface(opt_surface, false, ws, opt-rect )
         println("SDL_BlitSurface:%_" % [bs])
         call-SDL_UpdateWindowSurface(p)
         call-SDL_FreeSurface(opt_surface)
   
   while true :
      println("%_ %_ %_" % [p, ws, ii])
   call-IMG_Quit()

