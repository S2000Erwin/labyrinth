defpackage labyrinth :
   import core
   import collections
   import cards
   import GameBoardGraphics
   import communicator
   import events

; stub
; todo: use mprint later
defn gprint<?T> (s : ?T ) :
   print(s)

defn gprintln<?T> (s : ?T ) :
   println(s)


defn doLog (log : True|False) -> False :
   println("doLog %_" % [log])

public defstruct Country :
   name  : String
   attrs : HashTable<String,?>

defn remove (country : Country|False, key : String ) -> True|False :
   match(country) :
      (c : Country) : remove(attrs(c), key)
      (f) : false

defn set (country : Country, k : String, v : ?) -> False :
   set(attrs(country), k, v)

defmethod print (o : OutputStream, country : Country ) :
   print(o, "%_ : [" % [name(country)])
   for attr in attrs(country) do :
      val k = key(attr)
      val v = value(attr)
      print(o, "  %_: %_" % [k, v] )
   println(o, "  ]")

defn to-country (name : String, xs : Tuple<KeyValue<String,?>>) -> Country :
   val h = HashTable<String,?>()
   for x in xs do :
      h[key(x)] = value(x)
   val country = Country(name, h)
   country

public defstruct Countries :
   c : HashTable<String,Country>

defn to-countries ( kvs : Tuple<KeyValue<String,?>> ) -> Countries :
   val t = Countries(HashTable<String,?>())
   for kv in kvs do :
      val name = key(kv)
      val country = to-country(name, value(kv))
      t[name] = country
   t

public defn get (countries : Countries, name : String) -> Country|False :
   get?(c(countries), name, false)
   
defn set (countries : Countries, name : String, country : Country) -> False :
   set(c(countries), name, country)

defmethod print (o : OutputStream, countries : Countries ) :
   val country-hash = c(countries)
   for country in country-hash do :
      print(o, value(country) )

val baseRoutes = [
   ["syria", "iraq"], ["iraq", "saudiarabia"], ["saudiarabia", "yemen"],
   ["saudiarabia", "gulfstates"], ["gulfstates", "iran"], ["afghanistan", "pakistan"],
   ["iraq", "gulfstates"], ["gulfstates", "pakistan"], ["afghanistan", "iran"],
   ["afghanistan", "centralasia"], ["centralasia", "iran"], ["iran", "turkey"], 
   ["iraq", "iran"], ["iran", "pakistan"],
   ["syria", "turkey"], ["syria", "lebanon"], ["syria", "jordan"],
   ["turkey", "serbia"], ["turkey", "schengen"], ["turkey", "russia"], ["turkey", "iraq"],
   ["caucasus", "iran"], ["caucasus", "turkey"], ["caucasus", "centralasia"],
   ["caucasus", "russia"], ["centralasia", "china"], ["centralasia", "russia"],
   ["russia", "serbia"], ["russia", "schengen"], ["lebanon", "schengen"], ["lebanon", "israel"],
   ["jordan", "israel"], ["jordan", "iraq"], ["jordan", "saudiarabia"],
   ["israel", "egypt"], ["yemen", "somalia"],
   ["egypt", "libya"], ["egypt", "sudan"],
   ["libya", "sudan"], ["libya", "schengen"], ["libya", "algeria"],
   ["somalia", "kenya"], ["somalia", "sudan"],
   ["sudan", "kenya"], ["algeria", "schengen"], ["algeria", "morocco"],
   ["morocco", "schengen"], ["serbia", "schengen"], ["uk", "canada"], 
   ["uk", "schengen"], ["uk", "us"], ["canada", "schengen"], ["canada", "us"],
   ["us", "schengen"], ["us", "philippines"], ["philippines", "thailand"], ["philippines", "indonesia"],
   ["indonesia", "thailand"], ["indonesia", "india"], ["indonesia", "pakistan"],
   ["indea", "pakistan"], ["thailand", "china"]
]

; Don't reorder this table. It is according to Random Schengen Table
val schengens = ["scandinavia", "benelux", "germany", "france", "spain", "italy", "easterneurope"]

; Shia-mix Country table (9.5)
val shiamixTable_tuple = [ 
   3 => "syria", 4 => "syria", 5 => "syria", 6 => "syria",
   7 => "iran", 8 => "saudiarabia", 9 => "turkey", 10 => "iraq",
   11 => "gulfstates", 12 => "yemen", 13 => "pakistan", 14 => "lebanon",
   15 => "afghanistan", 16 => "afghanistan", 17 => "afghanistan", 18 => "afghanistan"
]
val shiamixTable = HashTable<Int, String>()
for s in shiamixTable_tuple do :
   shiamixTable[key(s)] = value(s)

val usmarkers = [ "advisors", "unscr1973", "nato", "maerskalabama" ]
val jihadistmarkers = ["scsc", "qataricrisis", "trainingcamps", "bloodythursday", "3cupsoftea", "censorshop" ]

val board_tuple = [
   "us" => ["name" => "us", "govern" => "good"]
   "canada" => [ "name" => "canada" "govern" => "good" ]
   "uk" => [ "name" => "uk" "govern" => "good" "recruit" => 3 ]
   "spain" => [ "name" => "spain" "govern" => "good" "schengen" => true "recruit" => 2 ]
   "france" => [ "name" => "france" "govern" => "good" "schengen" => true "recruit" => 2 ]
   "italy" => [ "name" => "italy" "govern" => "good" "schengen" => true ]
   "benelux" => ["name" => "benelux", "govern" => "good", "schengen" => true],
   "germany" => ["name" => "germany", "govern" => "good", "schengen" => true],
   "scandinavia"=> ["name"=> "scandinavia", "govern"=> "good", "schengen" => true],
   "easterneurope"=> ["name" => "easterneurope", "govern" => "good", "schengen" => true],
   "serbia" => ["name" => "serbia", "govern" => "good"],
   "russia" => ["name"=> "russia", "govern" => "fair"],
   "caucasus" => ["name" => "caucasus", "govern" => "fair"],
   "iran" => ["name" => "iran", "govern" => "fair"],
   "israel" => ["name" => "israel", "govern" => "good", "posture" => "hard", "permposture" => true],
   "india" => ["name" => "india", "govern" => "good"],
   "china" => ["name" => "china", "govern" => "fair"],
   "thailand" => ["name" => "thailand", "govern" => "fair"],
   "philippines"=> ["name" => "philippinse", "govern" => "fair", "recruit" => 3],
   "kenya" => ["name" => "kenya", "govern" => "fair", "african" => true],

   ; Muslim countries
   "indonesia" => ["name" => "indonesia", "muslim" => true, "resource" => 3, "oil" => true, "sunni" => true],
   "pakistan" => ["name" => "pakistan", "muslim" => true, "resource" => 2, "arsenal" => 3 ],
   "afghanistan" => ["name" => "afghanistan", "muslim" => true, "resource" => 1],
   "centralasia" => ["name" => "centralasia", "muslim" => true, "resource" => 2, "sunni" => true],
   "gulfstates" => ["name" => "gulfstates", "muslim" => true, "resource" => 3, "oil" => true],
   "yemen" => ["name" => "yemen", "muslim" => true, "resource" => 1],
   "iraq" => ["name" => "iraq", "muslim" => true, "resource" => 3, "oil" => true],
   "saudiarabia" => ["name" => "saudiarabia", "muslim" => true, "resource" => 3, "oil" => true],
   "somalia" => ["name" => "somalia", "muslim" => true, "resource" => 1, "sunni" => true, "african" => true],
   "syria" => ["name" => "syria", "muslim" => true, "resource" => 2, "sunni" => true],
   
   "jordan" => ["name" => "jordan", "muslim" => true, "resource" => 1, "sunni" => true],
   "turkey" => ["name" => "turkey", "muslim" => true, "resource" => 2],
   "lebanon" => ["name" => "lebanon", "muslim" => true, "resource" => 1],
   "egypt" => ["name" => "egypt", "muslim" => true, "resource" => 3, "sunni" => true],
   "sudan" => ["name" => "sudan", "muslim" => true, "resource" => 1, "oil" => true, "sunni" => true, "african" => true],
   "libya" => ["name" => "libya", "muslim" => true, "resource" => 1, "oil" => true, "sunni" => true, "african" => true],
   "algeria" => ["name" => "algeria", "muslim" => true, "resource" => 2, "oil" => true, "sunni" => true, "african" => true],
   "morocco" => ["name" => "morocco", "muslim" => true, "resource" => 2, "sunni" => true, "african" => true]
]
val awakenBoard_tuple = [
   "mali" => ["name" => "mali" "muslim" => true "resource" => 1, "sunni" => true "african" => true ]
   "nigeria" => [ "name" => "algeria" "govern" => "poor" "african" => true ]
   "syria" => [ "name" => "syria" "muslim" => true "resource" => 2 "arsenal" => 2 ]
   "iran" => ["name" => "iran" "arsenal" => 1]
]
val awakenBoard : HashTable<String, Country> = HashTable<String, Country>()
for c in awakenBoard_tuple do :
   val k = key(c) as String
   val v = value(c)
   awakenBoard[k] = to-country(k, v)

val ISILHMBoard_tuple = [
   "nigeria" => [ "name" => "nigeria" "muslim" => true "resource" => 2 "sunni" => true "african" => true ]
]

val random_muslim_country = [
      ["morocco", "syria", "-"],
      ["algeria", "jordan", "indonesia"],
      ["libya", "turkey", "lebanon"],
      ["egypt", "saudiarabia", "iraq"],
      ["sudan", "gulfstates", "afghanistan"],
      ["somalia", "yemen", "pakistan"]
   ]
val random_muslim_country2 = ["centralasia", "centralasia", "iraq", "mali", "nigeria", "nigeria"]

val personalities = [110, 111, 112, 115, 116, 215, 216, 219, 225, 237, 328, 329, 338, 342, 352]

val ISILHMSetup_tuple = [
   "syria" => [
      "name" => "syria",
      "align" => "neutral",
      "govern" => "fair",
      "caliphate" => "capital",
      "civilwar" => true,
      "militia" => 3,
      "activecell" => 5
   ],
   "iraq" => [
      "name" => "iraq",
      "align" => "neutral",
      "govern" => "poor",
      "caliphate" => "country",
      "civilwar" => true,
      "militia" => 3,
      "activecell" => 4
   ],
   "yemen" => [
      "name" => "yemen",
      "align" => "neutral",
      "govern" => "poor",
      "civilwar" => true,
      "militia" => 2,
      "sleepercell" => 2
   ],
   "gulfstates"=> [
      "name" => "gulfstates",
      "align" => "ally",
      "govern" => "fair",
      "troop" => 2
   ],
   "afghanistan" => [
      "name" => "afghanistan",
      "align" => "ally",
      "govern" => "poor",
      "troop" => 2,
      "sleepercell" => 1
   ],
   "nigeria"=> [
      "name" => "nigeria",
      "muslim" => true,
      "sunni" => true,
      "align" => "neutral",
      "govern" => "poor",
      "resource" => 2,
      "sleepercell" => 1,
      "african" => true
   ],
   "uk" => [
      "name" => "uk",
      "posture" => "hard"
   ]
]

val awakenRoutes = [
   ["mali", "morocco"], ["mali", "algeria"], ["mali", "nigeria"], ["nigeria", "sudan"], ["nigeria", "kenya"]
]

val surge-decks = [ 
   [
      1, 10, 12, 13, 15, 16, 18, 19, 20, 21, 22, 24, 25, 28, 29, 
      30, 32, 33, 35, 36, 40, 42, 45, 46, 49, 50, 52, 53, 60, 63, 
      68, 70, 72, 73, 74, 77, 78, 79, 81, 82, 83, 89, 90, 91, 93, 
      95, 97, 100, 101, 103, 105, 106, 107, 108, 111, 112, 113, 118, 119, 120
   ], [
      123, 124, 127, 128, 130, 131, 134, 135, 136, 139, 140, 141, 143, 146, 148,
      153, 154, 160, 161, 162, 163, 164, 168, 170, 172, 175, 176, 177, 179, 185,
      186, 190, 191, 195, 196, 197, 198, 199, 200, 202, 203, 205, 206, 207, 208,
      210, 211, 212, 213, 214, 219, 220, 221, 223, 227, 228, 229, 230, 237, 239
   ] 
]

public defstruct Labyrinth :
   awakening : True|False with : (setter => set-awakening)
   foreverwar : True|False with : (setter => set-foreverwar)
   scenario : String
   usplayer : String with : (setter => set-usplayer)
   jihadistplayer : String with : (setter => set-jihadistplayer)
   board : Countries with : (setter => set-board)
   countries : Countries with : (setter => set-countries)
   routes : Vector<[String,String]> with : (setter => set-routes)
   deck : Vector<Int>
   abort : True|False with : (setter => set-abort)
   reshuffled : True|False with : (setter => set-reshuffled)
   currentplayer : String with : (setter => set-currentplayer)
   currentphase : Int with : (setter => set-currentphase)
   firstPlot : True|False with : (setter => set-firstPlot)
   firstPlotCard : Int with : (setter => set-firstPlotCard)
   heldCard : True|False with : (setter => set-heldCard)
   lapsing : Vector<Int>
   plots : Vector<[String, Int|String]>
   usedPlots : Vector<Int|String>
   spentUnits : Vector<[String, String]>
   cellcamps : Int with : (setter => set-cellcamps)
   maxcamps : Int with : (setter => set-maxcamps)
   lesscell : Int with : (setter => set-lesscell)
   plotSuccess : True|False with : (setter => set-plotSuccess)
   plotAvailables : Vector<String|Int> 
   nbDeck : Int with : (setter => set-nbDeck)
   turn : Int with : (setter => set-turn)
   trooptrack : Int with : (setter => set-trooptrack)
   offmap : Int with : (setter => set-offmap)
   funding : Int with : (setter => set-funding)
   celltrack : Int with : (setter => set-celltrack)
   prestige : Int with : (setter => set-prestige)
   markers : Vector<String>
   loadedDeck :  Vector<Int>
   winMethod : String with : (setter => set-winMethod)
   currentphaseCountries : Vector<String>
   lastphaseCountries : Vector<String>
   discard : Vector<Int>
   removed : Vector<Int>
   ushand : Vector<Int>
   jihadisthand : Vector<Int>
   eventNotUsed : Vector<Int>
   eventUsed : Vector<Int>
   eventAsEvent : Vector<Int>
   usreserve : Int with : (setter => set-usreserve)
   jihadistreserve : Int with : (setter => set-jihadistreserve)
   gameend : True|False with : (setter => set-gameend)
   reason : String with : (setter => set-reason)
   currentcard : Int with : (setter => set-currentcard)
   gameBoard : GameBoardGraphics
   comm : Communicator|False with : (setter => set-comm)
   decks : Tuple<Tuple<Int>>|False with : (setter => set-decks)
   finalWin : True|False with : (setter => set-finalWin)
   winner : String|False with : (setter => set-winner)
   oppoEventDone : True|False with : (setter => set-oppoEventDone)
   needRemove : True|False with : (setter => set-needRemove)
   plotOp : True|False with : (setter => set-plotOp)


defmethod print (o : OutputStream, lab : Labyrinth) :
   print( o, "GR=%_ IR=%_ FGC=%_ PIC=%_ P=%_ F=%_ ",
      % [ getGoodResource(lab) getIslamResource(lab) getFGC(lab) getPIC(lab) prestige(lab) funding(lab)]
   )
   print( o,
      "T=%_ C=%_ US=%_ World="
      % [ getTroopLevel(lab) getCellOnMap(lab) getPosture(lab, "us")]
   )
   var gwot = getGWOTHard(lab)
   var worldStr : String = ""
   if gwot > 0:
      worldStr = "Hard "
   else if gwot < 0:
      worldStr = "Soft "
   else:
      worldStr = ""
   worldStr = append(worldStr, to-string(abs(gwot)))
   println(o, "%_" % [worldStr])
   println(o, "Awakening=%_ Reaction=%_ TroopsOnTrack=%_ Off-map=%_ CellsOnTrack=%_"
      % [countAwaken(lab) countReact(lab) trooptrack(lab) offmap(lab) celltrack(lab)]
   )
   println(o, "CellsInCamps=%_ CampsCapacity=%_ LessCells=%_"
      % [cellcamps(lab) maxcamps(lab) lesscell(lab)]
   )
   println(o, "CurrentPlots=%_ AvailablePlots=%_ UsedPlots=%_"
      % [plots(lab) plotAvailables(lab) usedPlots(lab)]
   )
   println(o, "USReserve=%_ JihadistReserve=%_" % [usreserve(lab) jihadistreserve(lab)] )
   println(o, "Lapsing=%_" % [ lapsing(lab) ])
   println(o, "Deck=%_" % [ deck(lab) ])
   println(o, "Discard=%_" % [ discard(lab) ])
   println(o, "Removed=%_" % [ removed(lab) ])

   qsort!(eventUsed(lab))
   println(o, "Events used=%_" % [ eventUsed(lab) ] )
   println(o, "CurrentPhaseCountries=%_" % [ currentphaseCountries(lab) ] )
   println(o, "LastPhaseCountries=%_" % [ lastphaseCountries(lab) ] )
   print(o, countries(lab))
   print(o, "Scenario=%_" % [ scenario(lab) ])

defn doLog (lab : Labyrinth, log : Int) -> False :
   if log >= 1 :
      doLog(true)
   else :
      doLog(false)


public defn make-labyrinth (  awakening : True|False, foreverwar : True|False, scenario : String, 
                              usplayer : String, jihadistplayer : String, 
                              terminal: True|False, log: Int ) -> Labyrinth :
   val lab = Labyrinth( awakening, 
                        foreverwar,
                        scenario,
                        usplayer,
                        jihadistplayer,
                        to-countries(board_tuple), 
                        Countries(HashTable<String,?>()),
                        Vector<[String,String]>(),
                        Vector<Int>(),    ; deck 
                        false,
                        false,      ; reshuffled
                        "jihadist"
                        0
                        false
                        0
                        false
                        Vector<Int>()
                        Vector<[String, Int|String]>()
                        Vector<Int|String>()
                        Vector<[String, String]>()
                        0
                        0
                        0
                        false
                        to-vector<Int>([1, 1, 1, 2, 2, 3])
                        3
                        1
                        15
                        0
                        7
                        15
                        6
                        Vector<String>()
                        Vector<Int>()        ; loadedDeck
                        ""
                        Vector<String>()
                        Vector<String>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        0
                        0
                        false
                        ""
                        0
                        make-GameBoardGraphics()          ; gameBoardGraphics
                        false          ; communicator
                        false          ; decks
                        false          ; finalWin
                        false          ; winner
                        false          ; oppoEventDone
                        false          ; needRemove
                        false          ; plotOp
                     )
   doLog(lab, log)   
   set-comm(lab, make-communicator(lab, usplayer, jihadistplayer, terminal, log))
   reset(lab)
   lab


; to-do : complete reset
defn reset (lab : Labyrinth) :
   println("Reset Game")
   if scenario(lab) == "Surge":
      set-awakening(lab, false)
   set-countries(lab, board(lab))
   set-routes(lab, to-vector<[String,String]>(baseRoutes))
   if awakening(lab) :
      for c in awakenBoard_tuple do :
         val cs = countries(lab) 
         val k = key(c) as String
         val v = value(c)
         cs[k] = to-country(k, v)
      val cs = countries(lab)
      val syria = cs["syria"]
      match(syria) : ( (syria : Country) : remove(syria, "sunni") )
      for route in awakenRoutes do :
         val result = find( fn ( x : [String,String], y : [String,String] ) -> True|False : (
                              if ( x[0] == y[0] and x[1] == y[1] ) or ( x[0] == y[1] and x[1] == y[0] ) :
                                 true
                              else :
                                 false )
                              routes(lab)
                              [route] )
         match(result) : ((result:False) : add(routes(lab), route) )
   if scenario(lab) == "ISILHM":
      val cs = countries(lab)
      for c in ISILHMBoard_tuple do :
         cs[key(c)] = to-country(key(c), value(c))
      for kv in ISILHMSetup_tuple do :
         val name = key(kv)
         val attrs = value(kv)
         for attr in attrs do:
            match( cs[name] ) :
               (c : Country) : set(c, key(attr), value(attr))
      remove(cs["iran"], "arsenal")
      remove(cs["syria"], "arsenal")
         
   ; gprint("scenario=%_" % [scenario(lab)])
   ; loadedDeck is for testing only
   clear(loadedDeck(lab))
   ; add(loadedDeck(lab), [195])
   clear(currentphaseCountries(lab))
   clear(lastphaseCountries(lab))
   clear(discard(lab))
   clear(removed(lab))
   clear(ushand(lab))
   clear(jihadisthand(lab))
   clear(eventNotUsed(lab))
   add-all(eventNotUsed(lab), deck(lab))
   clear(eventNotUsed(lab))
   clear(eventUsed(lab))
   clear(eventAsEvent(lab))
   set-usreserve(lab, 0)
   set-jihadistreserve(lab, 0)
   set-gameend(lab, false)
   set-reason(lab, "")
   clear(lapsing(lab))
   clear(plots(lab))
   clear(usedPlots(lab))
   clear(spentUnits(lab))
   set-cellcamps(lab, 0)
   set-maxcamps(lab, 0)
   set-lesscell(lab, 0)
   set-plotSuccess(lab, false)
   clear(plotAvailables(lab))
   add-all(plotAvailables(lab), to-vector<Int>([1, 1, 1, 2, 2, 3]))
   set-nbDeck(lab, 3)
   set-turn(lab, 1)
   clear(markers(lab))
   set-offmap(lab, 0)

   if scenario(lab) == "Surge":
      set-awakening(lab, false)
      set-foreverwar(lab, false)
      set-nbDeck(lab, 1)
      set-prestige(lab, 4)
      setPosture(lab, "us", "hard")
      set-trooptrack(lab, 5)
      set-funding(lab, 6)
      set-celltrack(lab, 15)
      setGovern(lab, "libya", "poor")
      setAlign(lab, "libya", "adversary")
      setGovern(lab, "syria", "fair")
      setAlign(lab, "syria", "adversary")
      addOneCell(lab, "syria", "recruit", true)
      setGovern(lab, "iraq", "poor")
      setAlign(lab, "iraq", "ally")
      setTroop(lab, "iraq", 5)
      addOneCell(lab, "iraq", "recruit", true)
      addOneCell(lab, "iraq", "recruit", true)
      addOneCell(lab, "iraq", "recruit", true)
      setRegimeChange(lab, "iraq", "tan")
      setMarker(lab, "iraq", "sadr", true)
      setMarker(lab, "iraq", "alanbar", true)
      addOneCell(lab, "iran", "recruit", true)
      setGovern(lab, "saudiarabia", "poor")
      setAlign(lab, "saudiarabia", "ally")
      addOneCell(lab, "saudiarabia", "recruit", true)
      setGovern(lab, "gulfstates", "fair")
      setAlign(lab, "gulfstates", "ally")
      setTroop(lab, "gulfstates", 2)
      setGovern(lab, "pakistan", "fair")
      setAlign(lab, "pakistan", "ally")
      addOneCell(lab, "pakistan", "recruit", true)
      setMarker(lab, "pakistan", "fata", true)
      setGovern(lab, "afghanistan", "poor")
      setAlign(lab, "afghanistan", "ally")
      setTroop(lab, "afghanistan", 3)
      for i in 0 to 2 do :
         addOneCell(lab, "afghanistan", "recruit", true)
      addOneAid(lab, "afghanistan", false)
      setRegimeChange(lab, "afghanistan", "tan")
      setMarker(lab, "afghanistan", "nato", 1)
      setGovern(lab, "somalia", "poor")
      setAlign(lab, "somalia", "neutral")
      addOneCell(lab, "somalia", "recruit", true)
      setBesiegedRegime(lab, "somalia")
      setGovern(lab, "indonesia", "fair")
      setAlign(lab, "indonesia", "neutral")
      addOneCell(lab, "indonesia", "recruit", true)
      setPosture(lab, "uk", "hard")
      setPosture(lab, "scandinavia", "soft")
      set-decks(lab, surge-decks) 
   clear(currentphaseCountries(lab))
   clear(lastphaseCountries(lab))
   gprint(lab)
   set-currentplayer(lab, "jihadist")
   set-currentphase(lab, 0)
   set-turn(lab, 0)  
   println("End Reset Game")

defn stopOneGame (lab : Labyrinth) :
   set-abort(lab, true)

public defn playOneGame (lab : Labyrinth, usplayer : String|False, jihadistplayer : String|False) :
   match(usplayer):
      (u : String) : set-usplayer(lab, u)
      (u) : u
   match(jihadistplayer):
      (j : String) : set-jihadistplayer(lab, j)
      (j) : j
   clear(eventNotUsed(lab))
   add-all(eventNotUsed(lab), deck(lab))
   shuffleDeck(lab)
   gprint("Shuffled Deck=")
   gprint(deck(lab))
   dealHands(lab)
   set-finalWin(lab, false)
   ; todo: try except is used in "web" ui
   try:
      label<False> break :
         while true :
            set-turn(lab, turn(lab)+1)
            gprintln("Turn %_" % [ turn(lab) ])
            if checkAutoWin(lab) :
               break(false)
            if playOneTurn(lab):
               break(false)
   catch (e : CommException) :
      gprintln("[CommException] reason:%_" % [reason(e)])
   ;except WebAbort:
   ;   return False, '', '', self.turn, ''
   ; determine winner
   set-reason(lab, "Auto Win")
   if finalWin(lab) == true:
      set-reason(lab, "Final Score")
   gprint(lab)
   endOneGame(comm(lab) as Communicator)
   [true, winner(lab), reason(lab), turn(lab), winMethod(lab)]

defn playOneTurn (lab : Labyrinth) :
   gprintln("playOneTurn")
   ; play one turn
   set-reshuffled(lab, false)
   set-currentplayer(lab, "jihadist")
   ; set-currentplayer(lab, "us")   ; testing only
   set-currentphase(lab, 0)
   set-firstPlot(lab, false)
   set-firstPlotCard(lab, 0)
   set-heldCard(lab, false)
   label<True|False> return :
      while not ((length(ushand(lab)) == 0 and length(jihadisthand(lab)) == 0)
                  or (heldCard(lab) and length(ushand(lab)) == 1 and length(jihadisthand(lab)) == 0)):
         playOneCard(lab, false)
         checkTrainingCamps(lab)
         if gameend(lab):
               return(true)
      endTurn(lab)

defn playOneCard (lab : Labyrinth, fromEvent : True|False) -> False:
   if not fromEvent:
      set-oppoEventDone(lab, false)
      set-heldCard(lab, false)
   set-needRemove(lab, false)
   set-plotOp(lab, false)
   if currentphase(lab) == 0:
      clear(currentphaseCountries(lab))
   gprintln("Current Player=%_ CurrentPhase=%_" % [currentplayer(lab) currentphase(lab)])

   var hand : Vector<Int>
   if currentplayer(lab) == "jihadist" :
      gprintln("Jihadist's Hand")
      hand = jihadisthand(lab)
   else :
      gprintln("US's hand")
      hand = ushand(lab)

   if length(hand) > 0:
      val card-id = queryCardPlay(
                        comm(lab) as Communicator, 
                        "Which card to play OR (g)ameboard OR (r)eport OR (c)ards OR countryname?",
                        to-tuple(hand) )
      gprintln("%_ plays card %_" % [currentplayer(lab) card-id])

      ; valid play
      remove-item(hand, card-id)
      set-currentcard(lab, card-id)
      val [ops, assoc, title] = getCardInfo(card-id)
      gprintln("%_ [%_] [%_] '%_'" % [card-id ops assoc title])

      if (assoc == "US" and currentplayer(lab) == "jihadist") or (
               assoc == "Jihadist" and currentplayer(lab) == "us") or card-id == 354 or card-id == 120:
            ; opponent card
            gprintln("This is opponent's card")
            if currentplayer(lab) == "us" and usplayer(lab) == "bot":
               gprintln("Bot ignores oppoenent's event")
               if card-id == 354 or card-id == 120:
                  playUSEvent(lab, card-id, false)
               playUSOps(lab, ops, fromEvent)
            else if currentplayer(lab) == "jihadist" and jihadistplayer(lab) == "bot":
               gprintln("Bot ignores opponent's event")
               if card-id == 354 or card-id ==120:
                  playJihadistEvent(lab, card-id, false)
               playJihadistOps(lab, ops, false)
            else:
               ; human or ai player
               val opsFirst = queryPlayOrder( 
                                 comm(lab) as Communicator, 
                                 "You play first(1) or second(2)?", 
                                 [1, 2] ) 
               if opsFirst == 1:
                  if currentplayer(lab) == "jihadist":
                        playJihadistOps(lab, ops, false)
                        if not plotOp(lab):
                           if firstPlot(lab):
                              if not oppoEventDone(lab):
                                    set-needRemove(lab, playUSEvent(lab, card-id, false))
                  else:
                        playUSOps(lab, ops, fromEvent)
                        if not oppoEventDone(lab) and not heldCard(lab):
                           set-needRemove(lab, playJihadistEvent(lab, card-id, false))
               else:
                  if currentplayer(lab) == "jihadist" :
                        set-needRemove(lab, playUSEvent(lab, card-id, false))
                        set-oppoEventDone(lab, true)
                        playJihadistOps(lab, ops, false)
                  else:
                        set-needRemove(lab, playJihadistEvent(lab, card-id, false))
                        set-oppoEventDone(lab, true)
                        playUSOps(lab, ops, fromEvent)
      else:
            ; not opponent's card
            val play = queryOpsOrEvent( 
                           comm(lab) as Communicator,
                           "(o)ps or (e)vent",
                           ["o", "e"] )
            if play == "o":
               gprintln("You choose Ops")
               if currentplayer(lab) == "jihadist" :
                  playJihadistOps(lab, ops, false)
               else:
                  playUSOps(lab, ops, fromEvent)
            else:
               if currentplayer(lab) == "jihadist":
                  set-needRemove(lab, playJihadistEvent(lab, card-id, false))
               else:
                  set-needRemove(lab, playUSEvent(lab, card-id, false))
               finishEvent(
                  comm(lab) as Communicator,
                  currentplayer(lab), 
                  card-id)

      ; one card play finished, clean up
      if card-id is Int and plotOp(lab) and jihadistplayer(lab) != "bot" :
            set-firstPlot(lab, true)
            set-firstPlotCard(lab, card-id as Int)

      if not heldCard(lab):
            if needRemove(lab) :
               add(removed(lab), currentcard(lab))
               gprintln("Card %_ is REMOVED" % [currentcard(lab)])
               gprintln("REMOVED Cards:%_" % [removed(lab)])
            else:
               doDiscard(lab, currentcard(lab))

      ; held card
      if heldCard(lab) and length(jihadisthand(lab)) == 0:
            set-currentphase(lab, 1)

   if not fromEvent:
      gprintln("Current Phase Countries:")
      for name in currentphaseCountries(lab) do :
         gprint(countries(lab)[name])
      set-currentphase(lab, currentphase(lab) + 1)

      if currentphase(lab) == 2:
         clear(lastphaseCountries(lab))
         add-all(lastphaseCountries(lab), currentphaseCountries(lab))
         clear(currentphaseCountries(lab))
         if currentplayer(lab) == "jihadist" :
            set-currentplayer(lab, "us")
         else:
            checkPlots(lab)
            set-currentplayer(lab, "jihadist")
         set-currentphase(lab, 0)

defn playJihadistOps (lab : Labyrinth, ops : Int, fromEvent : True|False) :
   gprintln("Play Jihadist Ops")
   val cardOps = ops
   var usedOps = 0
   var boost-ops = ops
   clear(spentUnits(lab))

   val validOps : Vector<String> = Vector<String>()
   var message = "Which Op to play:"
   val tooltips : Vector<String> = Vector<String>()
   if getCellOnMap(lab) > 0 :
      add(validOps, "t")
      message = append(message, ", (t)ravel")
      add(tooltips, "Travel")
   if cellAvailable(lab, false) > 0 :
      val validCountries = extract(lab, fn (x :String) : (getCell(lab, x, true) > 0 or isCadre(lab, x)), false)
      if length(validCountries) > 0:
            add(validOps, "r")
            message = append(message, ", (r)ecruit")
            add(tooltips, "Recruit")
   if length(plotAvailables(lab)) > 0 and getCellOnMap(lab) > 0:
      add(validOps, "p")
      message = append(message, ", (p)lot")
      add(tooltips, "Plot")
   label<False> break:
      for country in c(countries(lab)) do:
         val name = key(country)
         label<False> continue:
            if not isMuslim(lab, name):
               continue(false)
            if getGovern(lab, name) == "islamrule":
               continue(false)
            if name == "pakistan" and isMarker(lab, "pakistan", "benazirbhutto"):
               continue(false)
            if getCell(lab, name, true) - (getTroopStrength(lab, name, false) + getMilitia(lab, name)) >= 5:
               add(validOps, "m")
               message = append(message, ", (m)ajor jihad")
               add(tooltips, "Major Jihad")
               break(false)
   label<False> break:
      for country in c(countries(lab)) do:
         val name = key(country)
         label<False> continue:
            if not isMuslim(lab, name):
               continue(false)
            if name == "pakistan" and isMarker(lab, "pakistan", "benazirbhutto"):
               continue(false)
            if getCell(lab, name, true) > 0:
               add(validOps, "j")
               message = append(message, ", minor (j)ihad")
               add(tooltips, "Minor Jihad")
               break(false)

   var potentialOps = boost-ops + jihadistreserve(lab)
   if potentialOps > 3:
      potentialOps = 3
   gprintln("PotentialOps=%_" % [potentialOps])
   if jihadistreserve(lab) < 2 and ops < 3:
      add(validOps, "v")
      message = append(message, ", reser(v)e")
      add(tooltips, "Reserve")
   var opsType : String = ""
   usedOps = 0
   if length(validOps) == 0:
      gprintln("No Ops can be selected")
   else:
      opsType = queryOpType(comm(lab) as Communicator, message, to-tuple(validOps), to-tuple(tooltips))
   
   if opsType == "r":
      gprintln("Recruit Operation")
      boost-ops = queryBoostOps(lab, boost-ops, potentialOps)
      val validCountries = extract(lab, fn (x: String) : (isCadre(lab, x) or getCell(lab, x, true) > 0), false)
      ; reduce recruit by funding
      var buildable = min(boost-ops, cellAvailable(lab, false))
      val selections : Vector<String> = Vector<String>()
      gprintln("Jihadist can recruit %_ units" % [buildable])
      while length(selections) < buildable:
         val name = queryCountry(comm(lab) as Communicator, "jihadist", "Recruit in?", validCountries, "recruit", false)
         add(selections, name as String)
         gprintln(selections)

      for selection in selections do:
         ; get the country
         val country = (countries(lab))[selection]
         ; auto-recruit?
         val need = getRecruitNum(lab, selection)
         if need >= 6:
            val result = addOneCell(lab, selection, "recruit", false)
            add(spentUnits(lab), [selection, result])
            remove(country, "cadre")
         else:
            ; need to roll
            gprint("Need to roll <=%_ in %_" % [need selection])
            val dice = rollOnce(lab)
            if dice <= need:
               gprintln("Success")
               val result = addOneCell(lab, selection, "recruit", false)
               add(spentUnits(lab), [selection, result])
            else:
               gprintln("Failed")

      usedOps = length(selections)
   else if opsType == "t":
      gprintln("Travel")
      boost-ops = queryBoostOps(lab, boost-ops, potentialOps)
      val selections = Vector<[String, String]>()
      label<False> break:
         while length(selections) < boost-ops:
            val validDestinations = Vector<String>()
            for country in c(countries(lab)) do:
               val name = key(country)
               add(validDestinations, name)
            val toname? = queryCountry(comm(lab) as Communicator, "jihadist", "To which country?", to-tuple(validDestinations), "travelto", false)
            var toname : String = ""
            match(toname?):
               (t : String) : toname = t
               (t) : break(false)
            val validSources = Vector<String>()
            val adjSources = Vector<String>()
            for country in c(countries(lab)) do:
               val name = key(country)
               if getCell(lab, name, false) > 0:
                  add(validSources, name)
                  if isAdjacent(lab, name, toname, true):
                     add(adjSources, name)
            if length(validSources) == 0:
               break(false)
            gprintln("From: %_" % [validSources])
            gprintln("Adjacent to %_:: %_" % [toname adjSources])
            val fromname? = queryCountry(comm(lab) as Communicator, "jihadist", "From which country?", to-tuple(validSources), "travelfrom", false)
            var fromname = ""
            match(fromname?):
               (f : String) : fromname = f
               (f) : break(false)
            removeOneCell(lab, fromname)
            add(selections, [fromname, toname])
            gprintln("[(from,to)...] %_" % [selections])
         travel(lab, to-tuple(selections))
         usedOps = length(selections)
   else if opsType == "p":
      gprintln("Plot Operation")
      set-plotOp(lab, true)
      boost-ops = queryBoostOps(lab, boost-ops, potentialOps)
      val selections = selectAndActivate(lab, "p", boost-ops, "plot")
      ; roll
      match(selections):
         (xs : Tuple<String>) :
            plot(lab, boost-ops, xs)
            usedOps = length(xs)
         (xs) : false
   else if opsType == "j":
      gprintln("Minor Jihad")
      boost-ops = queryBoostOps(lab, boost-ops, potentialOps)
      val selections = selectAndActivate(lab, "j", ops, "minorjihad")
      match(selections):
         (xs : Tuple<String>) :
            usedOps = length(xs)
            ; roll
            minorjihad(lab, xs, false)
         (xs) : false
   else if opsType == "m":
      gprintln("Major Jihad")
      boost-ops = queryBoostOps(lab, boost-ops, potentialOps)
      val xs = selectAndActivate(lab, "m", boost-ops, "majorjihad")
      match(xs):
         (xs:Tuple<String>) :
            ; roll
            val selections = calNeed(lab, xs)
            val results = HashTable<String, [Int, Int]>()
            for [name, need] in selections do:
               label<False> continue:
                  if name == "pakistan" and isMarker(lab, "pakistan", "benazirbhutto"):
                     gprintln("No Jihad in Pakistan under Bhutto")
                     continue(false)
                  var mSuccess = 0
                  var mFail = 0
                  if get?(results, name, false) is-not False:
                     val result = results[name]
                     mSuccess = result[0]
                     mFail = result[1]
                  gprint("In %_ " % [name])
                  gprintln("Need to roll<=%_" % [to-string(need)] )
                  var drm = getAwaken(lab, name)
                  drm = drm - getReact(lab, name)
                  gprintln( "DRM=%_" % [to-string(drm)] )
                  var die = rollOnce(lab)
                  die = die + drm
                  if die <= need:
                     gprintln("Success")
                     add(spentUnits(lab), [name, "activecell"])
                     if getGovern(lab, name) == "poor":
                        mSuccess = mSuccess + 1
                     else:
                        worsenGovern(lab, name, false)
                     removeOneAid(lab, name)
                  else:
                     ; failed
                     gprintln("Jihad Failed")
                     if getGovern(lab, name) == "poor":
                        mFail = mFail + 1
                     removeOneActiveCellToTrack(lab, name)
                  results[name] = [mSuccess, mFail]
                  gprintln("result=%_" % [results])
            for result in results do:
               val name = key(result)
               val value = value(result)
               val [mSuccess, mFail] = value
               if mSuccess >= 2 or (isBesiegedRegime(lab, name) and mSuccess >= 1):
                  gprintln("Major Jihad Succeeded!")
                  toIslamrule(lab, name)
                  changeFunding(lab, getResource(lab, name))
                  if getTroopStrength(lab, name, true) > 0:
                     changePrestige(lab, (- 100))
               else if mFail + mSuccess >= 3:
                  gprintln("Major Failure")
                  shiftAlign(lab, name, "ally")
                  setBesiegedRegime(lab, name)
               gprint((countries(lab))[name])
            usedOps = length(selections)
         (f) : false
   else if opsType == "v":
      val oReserve = jihadistreserve(lab)
      set-jihadistreserve(lab, jihadistreserve(lab) + ops)
      set-jihadistreserve(lab, min(2, jihadistreserve(lab)) )
      gprintln("Jihadist Reserve from %_ to %_" % [oReserve jihadistreserve(lab)])
      usedOps = ops
   ; Reduce reserve only if really used
   if usedOps > cardOps:
      set-jihadistreserve(lab, 0)
      gprintln("Jihadist Reserve to 0")
   ; Radlicalization
   if jihadistplayer(lab) == "bot" and cardOps > usedOps:
      val maxOps1 = cardOps - usedOps  ; may be boosted
      var maxOps = maxOps1
      if maxOps < 3 and jihadistreserve(lab) > 0:
            maxOps = maxOps + jihadistreserve(lab)
      maxOps = min(3, maxOps)
      queryRadicalization(comm(lab) as Communicator, "jihadist", "Do any actions", maxOps1, maxOps, spentUnits(lab))
   checkAutoWin(lab)

defn travel (lab : Labyrinth, selections : Tuple<[String, String]>) :
   ; roll dice!
   for [fromname, toname] in selections do:
      if isAdjacent(lab, fromname, toname, true) and not (contains?(lapsing(lab), 169) and isSchengen(lab, toname)):
         ; auto-success
         add(spentUnits(lab), [toname, addOneCell(lab, toname, "travelto", false)])
         ; test the country
         testCountry(lab, toname)
      else:
         testCountry(lab, toname)
         val need = getGovernNum(lab, toname)
         var drm = 0
         if isMarker(lab, fromname, "trainingcamps"):
            drm = drm - 1
         gprint("Need <=%_ to %_ with drm=%_ " % [need toname drm])
         if rollOnce(lab) + drm <= need:
            gprintln("Success")
            add(spentUnits(lab), [toname, addOneCell(lab, toname, "travelto", false)])
         else :
            gprintln("Go to Track")
            if lesscell(lab) > 0:
               set-lesscell(lab, lesscell(lab) - 1)
            else if cellcamps(lab) < maxcamps(lab) :
               set-cellcamps(lab, cellcamps(lab) + 1)
            else:
               set-celltrack(lab, celltrack(lab) + 1)
            gprintln("Cell Track has %_" % [celltrack(lab)])

defn plot (lab : Labyrinth, ops : Int, selections : Tuple<String>) :
   for name in selections do :
      add(spentUnits(lab), [name, "activecell"])
      gprint("In %_ " % [name])
      val need = getGovernNum(lab, name)
      gprintln("Need to roll<=%_" % [need])
      val die = rollOnce(lab)
      if die <= need:
         val availables = to-vector<String|Int>(plotAvailables(lab))   ; clone
         if ops < 3:
            while contains?(availables, 3):
               remove-item(availables, 3)
         if ops < 2:
            while contains?(availables, 2):
               remove-item(availables, 2)
         gprintln("Success. Plots Available=%_" % [availables])
         if length(availables) > 0:
            val ans = queryPlot( comm(lab) as Communicator "Choose Plot" plotAvailables(lab) false) 
            match(ans):
               (ans : Int|String) : placePlot(lab name ans)
               (ans) : false 
      else:
            ; failed
            gprintln("Plot Failed")

defn placePlot (lab : Labyrinth, name : String, plot : String|Int):
   label<False> return :
      if not contains?(plotAvailables(lab), plot):
         return(false)
      add(plots(lab), [name, plot])
      remove-item(plotAvailables(lab), plot)
      gprintln("Plots: %_" % [plots(lab)])
      gprintln("Available Plots: %_" % [plotAvailables(lab)])
      testCountry(lab, name)
         
      
defn minorjihad (lab : Labyrinth, input-selections : Tuple<String>, ignoreUnit : True|False) -> Tuple<[String, String]>:
   val results = Vector<[String, String]>()
   val selections = calNeed(lab, input-selections)
   for [name, need] in selections do:
      label<False> continue:
         if name == "pakistan" and isMarker(lab, "pakistan", "benazirbhutto"):
            gprintln("No Jihad in Pakistan under Bhutto")
            continue(false)
         gprintln("Need to roll<=%_ in %_" % [need name])
         var drm = getAwaken(lab, name)
         drm = drm - getReact(lab, name)
         gprintln("DRM=%_" % [drm])
         var die = rollOnce(lab)
         die = die + drm
         if die <= need:
            if not ignoreUnit:
               add(spentUnits(lab), [name, "activecell"])
            worsenGovern(lab, name, false)
            removeOneAid(lab, name)
            add(results, [name, "success"])
         else:
            ; failed
            gprintln("Jihad Failed")
            if not ignoreUnit:
               removeOneActiveCellToTrack(lab, name)
            add(results, [name, "fail"])
         gprint((countries(lab))[name])
   to-tuple(results)


defn queryBoostOps (lab : Labyrinth, ops : Int, potentialOps : Int) -> Int:
   label<Int> return :
      if ops == potentialOps:
         return(ops)
      if currentplayer(lab) == "us":
         gprintln("Current Ops:%_ US Reserve:%_" % [ ops usreserve(lab)])
      else:
         gprintln("Current Ops:%_ Jihadist Reserve:%_" % [ ops jihadistreserve(lab)])
      val msg = "Do you want to boost Ops, (y)es or (n)o?"
      val ans = queryBoostOps(comm(lab) as Communicator, msg, ["y", "n"])
      potentialOps when ans == "y" else ops

defn playUSOps (lab : Labyrinth, input-ops : Int, fromEvent : True|False) -> False :
   label<False> return :
      gprintln("Play US Ops")
      val cardOps = input-ops
      var ops = input-ops
      val potentialOps = min{3, _} $ ops + usreserve(lab)
      var usedOps : Int = 0
      var opsType : String = ""
      val validOps = to-vector<String>(["w", "d", "p"])
      var message = "Which Ops?: (w)arOfIdeas, (d)isrupt, de(p)loy"
      val tooltips = to-vector<String>(["War of Ideas", "Disrupt", "Deploy"])
      if length(plots(lab)) > 0 and potentialOps >= 3:
         add(validOps "a")
         message = append(message, ", (a)lert")
         add(tooltips, "Alert")
      if potentialOps >= 3 and getPosture(lab, "us") == "hard" and countIRCountries(lab) > 0:
         add(validOps, "rc")
         message = append(message, ", (rc)RegimeChange")
         add(tooltips, "Regime Change")
      if potentialOps >= 3 and getPosture(lab, "us") == "soft" and countRCCountries(lab) > 0:
         add(validOps, "wd")
         message = append(message, ". (wd)WithDraw")
         add(tooltips, "Withdraw")
      if (  (usplayer(lab) == "bot" and (length(ushand(lab)) > 0) and (potentialOps >= 3)) or
            (usplayer(lab) != "bot" and (ops >= 3) and hasUSHand3Op(lab) and currentphase(lab) == 0)) :
         add(validOps, "ra")
         message = append(message, ", (ra)Reassessment")
         add(tooltips, "Reassessment")
      if ops < 3 and usreserve(lab) < 2:
         add(validOps, "v")
         message = append(message, ", reser(v)e")
         add(tooltips, "Reserve")
      if length(ushand(lab)) == 0 and not fromEvent:
         add(validOps, "h")
         message = append(message, ", (h)old")
         add(tooltips, "Hold Card")
      if usplayer(lab) == "bot":
         add(validOps, "hs")  ; home security. No need display msg

      opsType = queryOpType(comm(lab) as Communicator, message, validOps, tooltips)

      if opsType == "w":
         gprintln("War Of Ideas")
         ops = queryBoostOps(lab, ops, potentialOps)
         val validCountries = to-tuple{_} $ cat( 
            extract( 
               lab
               fn (x) : 
                  isMuslim(lab, x) and
                  (getAlign(lab, x) == "ally" or getAlign(lab, x) == "neutral") and
                  not (getAlign(lab, x) == "ally" and getGovern(lab, x) == "good") and
                  (  not isRegimeChange(lab, x) or isRegimeChange(lab, x) and 
                     ((getTroopStrength(lab, x, false) + getMilitia(lab, x) - getCell(lab, x, true)) >= 5) 
                  ) and
                  ops >= getGovernNum(lab, x)
               false
            )
            extract(
               lab
               fn (x) : 
                  not isMuslim(lab, x) and not isPermPosture(lab, x) and x != "iran" and ops >= getGovernNum(lab, x)
               false
            )
         )
         ; validCountries established
         gprint(validCountries)
         if length(validCountries) <= 0:
            return(false)
         val name = queryCountry(comm(lab) as Communicator, "us", "War of Ideas", validCountries, "woi", false) as String
         usedOps = getGovernNum(lab, name)
         gprintln("%_ Ops used for WoI" % [usedOps])
         if isMuslim(lab, name):
            val drm = getWoiDRM(lab, name, false)
            gprint("DRM=%_" % [drm])
            val die = rollOnce(lab) + drm
            if die >= 5:
               if getAlign(lab, name) == "ally":
                  improveGovern(lab, name)
               else:
                  shiftAlign(lab, name, "ally")
            else if die == 4:
               if getAid(lab, name) < 1:
                  addOneAid(lab, name, false)
         else :
            ; non-Muslim
            rollPosture(lab, name, 0)
            if getPosture(lab, name) == getPosture(lab, "us") :
               changePrestige(lab, 1)
         gprint(countries(lab)[name])
      else if opsType == "d":
         gprintln("Disrupt %_" % [ops])
         ops = queryBoostOps(lab, ops, potentialOps)
         val validCountries = Vector<String>()
         for country in c(countries(lab)) do:
            label<False> continue :
               val name = key(country)
               if getGovernNum(lab, name) > ops:
                  continue(false)
               if getCell(lab, name, false) <= 0 and not isCadre(lab, name):
                  continue(false)
               if isMuslim(lab, name):
                  if isMarker(lab, name, "fata") and not isRegimeChange(lab, name):
                     continue(false)
                  if getAlign(lab, name) == "ally" :
                     add(validCountries, name)
                     continue(false)
               else:
                  if name == "iran" :
                     continue(false)
                  add(validCountries, name)
                  continue(false)
               if getTroopStrength(lab, name, false) >= 2 or getMilitia(lab, name) >= 1:
                  if isMarker(lab, name, "fata") and not isRegimeChange(lab, name):
                     continue(false)
                  add(validCountries, name)
                  continue(false)
         ; validCountries established
         gprint(validCountries)
         if length(validCountries) <= 0:
            return(false)
         val name = queryCountry(comm(lab) as Communicator, "us", "Disrupt in which country?", to-tuple(validCountries), "disrupt", false) as String
         usedOps = getGovernNum(lab, name)
         disrupt(lab, name)
         val country = (c(countries(lab)))[name]
         match(country):
            (country : Country) :  gprint(country)
            (c) : false
      else if opsType == "a":
         gprintln( "Alert %_ " % [plots(lab)] )
         val ans = queryAlert(comm(lab) as Communicator, "Which Plot?", plots(lab))
         alert(lab, ans)
         usedOps = 3
      else if opsType == "p":
         gprint("Deploy %_" % [ops])
         ops = queryBoostOps(lab, ops, potentialOps)
         val validDestinations = to-vector<String>(["track"])
         for country in c(countries(lab)) do :
            val name = key(country)
            if isMuslim(lab, name) and getAlign(lab, name) == "ally" and getGovernNum(lab, name) <= ops:
               add(validDestinations, name)
                  
         val validSources = Vector<String>()
         if trooptrack(lab) > 0:
            add(validSources, "track")
         for country in c(countries(lab)) do:
            val name = key(country)
            label<False> continue :
               if getTroop(lab, name) > 0:
                  if isRegimeChange(lab, name):
                     if (getTroopStrength(lab, name, false) + getMilitia(lab, name) - getCell(lab, name, true)) <= 5:
                        continue(false)
                  add(validSources, name)
         if length(validDestinations) > 0 and length(validSources) > 0:
            val dst = queryCountry(comm(lab) as Communicator, "us", "Where to?", to-tuple(validDestinations), "troopto", false) as String
            remove-item(validSources, dst)
            if length(validSources) > 0:
               val src = queryCountry(comm(lab) as Communicator, "us", "From where?", to-tuple(validSources), "troopfrom", false) as String
               val troop = getTroop(lab, src)
               var available = troop
               if isRegimeChange(lab, src):
                  val surplus = max{0, _} $ (getTroopStrength(lab, src, false) + getMilitia(lab, src) - getCell(lab, src, true) - 5)
                  available = surplus
               gprintln("Available to Move: %_" % [available])
               val ans = queryTroopMove(comm(lab) as Communicator, "How many to move?", 1, available)
               setTroop(lab, src, troop - ans)
               setTroop(lab, dst, getTroop(lab, dst) + ans)
               usedOps = 1 when dst == "track" else getGovernNum(lab, dst)
      else if opsType == "rc":
         val validDestinations = Vector<String>()
         for country in c(countries(lab)) do :
            val name = key(country)
            label<False> continue :
               if not isMuslim(lab, name):
                  continue(false)
               if getGovern(lab, name) != "islamrule":
                  continue(false)
               add(validDestinations, name)
         val validSources = Vector<String>()
         if trooptrack(lab) >= 6 :
            add(validSources, "track")
         for country in c(countries(lab)) do :
            val name = key(country)
            label<False> continue :
               if getTroop(lab, name) >= 6:
                  if isRegimeChange(lab, name):
                     if getTroopStrength(lab, name, false) + getMilitia(lab, name) - getCell(lab, name, true) < 11:
                        continue(false)
                  add(validSources, name)
         ; validDestinations and validSources established
         if length(validSources) > 0 and length(validDestinations) > 0:
            val dst = queryCountry(comm(lab) as Communicator, "us", "Where to?", to-tuple(validDestinations), "regimechangeto", false) as String
            remove-item(validSources, dst)
            if length(validSources) > 0:
               val src = queryCountry(comm(lab) as Communicator, "us", "From where?", to-tuple(validSources), "regimechangefrom", false) as String
               val troop = getTroop(lab, src)
               var available = troop
               if isRegimeChange(lab, src):
                  val surplus = max{0, _} $ getTroopStrength(lab, src, false) + getMilitia(lab, src) - getCell(lab, src, true) - 5
                  available = surplus
               gprintln("Available to Move: %_" % [available])
               val ans = queryTroopMoveRegimeChange(comm(lab) as Communicator, "How many to move?", 6, available)
               setTroop(lab, src, troop - ans)
               setTroop(lab, dst, getTroop(lab, dst) + ans)
               setActiveCell{lab, dst, _} $ { getActiveCell(lab, dst, false) + _ } $ getSleeperCell(lab, dst, false)
               setSleeperCell(lab, dst, 0)
               setAlign(lab, dst, "ally")
               rollGovern(lab, dst)
               setRegimeChange(lab, dst, "green")
               rollPrestige(lab)
         usedOps = 3
      else if opsType == "wd":
         val validDestination = to-vector<String>(["track"])
         val validSources = Vector<String>()
         for country in c(countries(lab)) do:
            val name = key(country)
            if isRegimeChange(lab, name):
               add(validSources, name)
            else:
               if getAlign(lab, name) == "ally" :
                  add(validDestination, name)
         ; established
         if length(validSources) > 0 and length(validDestination) > 0:
            val dst = queryCountry(comm(lab) as Communicator, "us", "Where To?", to-tuple(validDestination), "withdrawto", false) as String
            remove-item(validSources, dst)
            if length(validSources) > 0:
               val src = queryCountry(comm(lab) as Communicator, "us", "From where?", to-tuple(validSources), "withdrawfrom", false) as String
               val available = getTroop(lab, src)
               gprintln("Available Troop: %_" % [available])
               val ans = queryTroopMoveWithdraw(comm(lab) as Communicator, "Withdraw how many?", 1, available)
               setTroop(lab, src, available - ans)
               setTroop(lab, dst, getTroop(lab, dst) + ans)
               removeMarkers(lab, src, ["aid"])
               setBesiegedRegime(lab, src)
               rollPrestige(lab)
         usedOps = 3
      else if opsType == "ra":
         ; special case for Bot
         if usplayer(lab) == "bot" :
            val card = (ushand(lab))[0]
            val [nextOps, nextAssoc, nextTitle] = getCardInfo(card)
            gprintln("Next Card is [%_] [%_], %_" % [nextOps, nextAssoc, nextTitle])
            val totalOps = ops + nextOps
            gprintln("TotalOps=%_ US Reserve=%_" % [totalOps, usreserve(lab)] )
            if totalOps + usreserve(lab) >= 6:
               remove(ushand(lab), 0)
               doDiscard(lab, card)
               switchPosture(lab, "us")
               if totalOps < 6:
                  set-usreserve(lab, 0)
                  gprintln("US Reserve to 0")
         else:
            var opPlayed : True|False = false
            if not oppoEventDone(lab):
               val [cardOps, assoc, title] = getCardInfo(currentcard(lab))
               if assoc == "Jihadist":
                  switchPosture(lab, "us")
                  opPlayed = true
                  set-needRemove(lab, playJihadistEvent(lab, currentcard(lab), false))
                  set-oppoEventDone(lab, true)
            gprintln("Play another 3 Ops Card")
            val validCards = Vector<Int>()
            for card-id in ushand(lab) do :
               val [cardOps, assoc, title] = getCardInfo(card-id)
               if cardOps == 3:
                  add(validCards, card-id)
            gprintln(validCards)
            val ans = queryCardPlay(comm(lab) as Communicator, "Choose Card ID", to-tuple(validCards))
            val [cardOps, assoc, title] = getCardInfo(ans)
            remove-item(ushand(lab), ans)
            if opPlayed:
               if assoc == "Jihadist":
                  if playJihadistEvent(lab, ans, false):
                     add(removed(lab), ans)
                  else:
                     doDiscard(lab, ans)
               else:
                  doDiscard(lab, ans)
            else:
               val card-id = ans
               if assoc == "Jihadist":
                  val ans = queryReassessment(comm(lab) as Communicator, "Do you want to switch now?", ["y", "n"])
                  if ans == "y":
                     switchPosture(lab, "us")
                     opPlayed = true
                  else:
                     if playJihadistEvent(lab, card-id, false) :
                        add(removed(lab), card-id)
                     else:
                        doDiscard(lab, card-id)
               else:
                  doDiscard(lab, card-id)
            if not opPlayed:
               switchPosture(lab, "us")
               opPlayed = true
         set-currentphase(lab, 1)
         usedOps = 3
      else if opsType == "v" :
         val oReserve = usreserve(lab)
         set-usreserve{lab, _} $ min{2, _} $ usreserve(lab) + ops
         usedOps = ops
         gprintln("US Reserve from %_ to %_" % [oReserve usreserve(lab)])
      else if opsType == "h" :
         add(ushand(lab), currentcard(lab))
         set-heldCard(lab, true)
         usedOps = ops
      else if opsType == "hs" :
         usedOps = 0
      ; card Ops is done. Proceed to epilog
      if usedOps > cardOps:
         set-usreserve(lab, 0)
         gprintln("US Reserve to 0")
      else if usedOps < cardOps:
         if usplayer(lab) == "bot" :
            queryHomelandSecurity{comm(lab) as Communicator, _} $ cardOps - usedOps
      checkAutoWin(lab)
      false

defn disrupt (lab : Labyrinth, name : String) :
   var affect : Int = 1
   var pInc : Int = 0
   if getPosture(lab, name) == "hard" :
      affect = 2
   else if getTroopStrength(lab, name, false) >= 2:
      if isMarker(lab, "iraq", "alanbar") and (name == "iraq" or name == "syria") :
         affect = 1
         pInc = 1
      else:
         affect = 2
         pInc = 1
   else if getMilitia(lab, name) >= 1 and isAdvisors(lab, name):
      affect = 2
   ; effect
   changePrestige(lab, pInc)

   affect = min(affect, getCell(lab, name, false))
   if getCell(lab, name, false) == 0:
      if not (isMarker(lab, "iraq", "alanbar") and (name == "iraq" or name == "syria")):
         removeCadre(lab, name)
   else:
      if getActiveCell(lab, name, false) == 0:
         ; only sleeper
         val cell = getSleeperCell(lab, name, false)
         setSleeperCell(lab, name, cell - affect)
         setActiveCell(lab, name, getActiveCell(lab, name, false) + affect)
      else if getSleeperCell(lab, name, false) == 0:
         ; only active
         val cell = getActiveCell(lab, name, false)
         for i in 0 to affect do:
            removeOneActiveCellToTrack(lab, name)
         if getActiveCell(lab, name, true) == 0:
            setCadre(lab, name)
      else:
         if affect == 2 and getActiveCell(lab, name, false) == 1 and getSleeperCell(lab, name, false) == 1:
            removeOneActiveCellToTrack(lab, name)
            setSleeperCell(lab, name, 0)
            setActiveCell(lab, name, 1)
         else:
            for i in 0 to affect do:
               val active = getActiveCell(lab, name, false)
               val sleeper = getSleeperCell(lab, name, false)
               gprintln("Active: %_" % [active])
               gprintln("Sleeper: %_" % [sleeper])
               if sleeper == 0:
                  removeOneActiveCellToTrack(lab, name)
               else:
                  val ans = queryActiveOrSleeper(comm(lab) as Communicator, "us", "(a)ctive or (s)leeper?", ["a", "s"])
                  if ans == "a" :
                     removeOneActiveCellToTrack(lab, name)
                  else:
                     setSleeperCell(lab, name, sleeper - 1)
                     setActiveCell(lab, name, active + 1)
      if getCell(lab, name, true) == 0:
         setCadre(lab, name)

defn alert (lab : Labyrinth, index : Int):
   val plot = (plots(lab))[index]
   remove(plots(lab), index)
   val [name, value] = plot
   if value == "w":
      if awakening(lab) :
         changePrestige(lab, 1)
   else:
      if awakening(lab) :
         add(usedPlots(lab), value)
      else:
         add(plotAvailables(lab), value)

defn endTurn (lab : Labyrinth) -> True|False :
   gprintln("End Turn")
   if not isPirates(lab):
      gprintln("Jihadist Funding -1")
      changeFunding(lab, (- 1))
   if countIRCountries(lab) > 0:
      gprintln("IR Country")
      changePrestige(lab, (- 1))
   if (getGWOTHard(lab) >= 3 and getPosture(lab, "us") == "hard") or (
         getGWOTHard(lab) <= (- 3) and getPosture(lab, "us") == "soft"):
      gprintln("US Posture same as World S3/H3")
      changePrestige(lab, 1)
   if usplayer(lab) != "bot":
      set-usreserve(lab, 0)
   if jihadistplayer(lab) != "bot":
      set-jihadistreserve(lab, 0)
   add-all(plotAvailables(lab), usedPlots(lab))
   clear(usedPlots(lab))
   polarization(lab)
   attrition(lab)
   label<True|False> return :
      if checkAutoWin(lab):
         return(true)
      if dealHands(lab):
         set-reshuffled(lab, true)
      if reshuffled(lab):
         set-nbDeck(lab, nbDeck(lab) - 1)
         if nbDeck(lab) == 0:
            set-gameend(lab, true)
            determineFinalWinner(lab)
            return(true)
      if isMarker(lab, "china", "scsc"):
         if getPosture(lab, "us") == getPosture(lab, "china"):
               set-trooptrack(lab, trooptrack(lab) + 2)
               set-offmap(lab, offmap(lab) - 2)
               removeMarker(lab, "china", "scsc", true)
               gprintln("2 Troops from South China Sea Crisis return")
      if contains?(lapsing(lab), 179):
         set-trooptrack(lab, trooptrack(lab) + 2)
         set-offmap(lab, offmap(lab) - 2)
         gprintln("2 Troops from Korean Crisis return")
      if contains?(lapsing(lab), 239):
         for country in c(countries(lab)) do:
            setAttr(lab, key(country), "truce", false)
      clear(lapsing(lab))
      flipRegimeChange(lab)
      gprint(lab)
      false

defn checkPlots (lab : Labyrinth) :
   label<False> return :
      gprintln("Check Plots")
      if length(plots(lab)) <= 0:
         set-plotSuccess(lab, false)
         return(false)
      for [name, plot] in plots(lab) do :
         if (isCivilWar(lab, name) or isRegimeChange(lab, name)) and (getTroopStrength(lab, name, false) > 0 or isAdvisors(lab, name)):
            set-plotSuccess(lab, true)
         gprintln("In %_ Plot=%_" % [name plot])
         if isMuslim(lab name) or name == "iran":
            match(plot):
               (plot : String) :
                  switch { plot == _ } :
                     "-w" : changeFunding(lab, (- 100) )
                     'w'  : changeFunding(lab, 100)
               (plot : Int) :
                  if getGovern(lab, name) == "good":
                     if plot < 0:
                        changeFunding(lab (- 2) )
                     else:
                        changeFunding(lab 2)
                  else:
                     if plot < 0:
                        changeFunding(lab (- 1) )
                     else:
                        changeFunding(lab 1)
               (plot) : false
            if getTroopStrength(lab, name, true) > 0:
               match(plot) :
                  (plot : String) : changePrestige(lab (- 100))
                  (plot) : changePrestige(lab -1)
            if isMuslim(lab name):
               var rolls = 0
               match(plot) :
                  (plot : String) : rolls = 3
                  (plot : Int) : rolls = abs(plot)
               for roll in 0 to rolls do:
                  val need = getGovernNum(lab, name)
                  gprintln("Need roll<=%_" % [need])
                  val die = rollOnce(lab)
                  if die <= need:
                     gprintln("Success. Worsen Governance")
                     worsenGovern(lab name false)
                     removeOneAid(lab name)
         else:
            ; non-Muslim
            if name == "us" :
               match(plot) :
                  (plot : String) :
                     gprintln("Game Over. Jihadist Wins")
                     set-gameend(lab true)
                     set-winner(lab "jihadist")
                     set-winMethod(lab "WMD in US")
                  (plot) :
                     changeFunding(lab 100)
                     rollPosture(lab "us" 0)
                     rollPrestige(lab)
            else:
               ; non-muslim non=US
               match(plot) :
                  (plot : String) :
                     gprintln("Funding to 9")
                     changeFunding(lab 100)
                  (plot : Int) :
                     val incF = abs(plot) * ( 2 when getGovern(lab name) == "good" else 1 )
                     changeFunding(lab, incF)
               if not isPermPosture(lab name) :
                  rollPosture(lab name 0)
                     match(plot) :
                        (plot : String) :
                           if usplayer(lab) != "bot" and jihadistplayer(lab) != "bot" :
                              val ans = queryReroll(comm(lab) as Communicator, "Do you want to re-roll?", ["y", "n"])
                              if ans == "y":
                                 rollPosture(lab name, 0)
               if contains?(schengens name):
                  val selections = Vector<String>()
                  while length(selections) < 2:
                     val validCountries = to-vector<String>(schengens)
                     remove-item(validCountries name)
                     for selection in selections do :
                        remove-item(validCountries selection)
                     gprintln(validCountries)
                     val ans = queryCountry(comm(lab) as Communicator, "jihadist", "Choose Schengen Country to Roll Posture", 
                                             to-tuple(validCountries), "schengenposture", false)
                     if ans is String :
                        add(selections, ans as String)
                  for selection in selections do :
                     rollPosture(lab, selection, 0)
         if name == "india" and isMarker(lab, "india", "indopakistanitalks") :
               gprintln("Remove Indo-Pakistani Talks")
               removeMarker(lab, "india", "indopakistanitalks", true)
         match(plot):
            (plot : Int) :
               if awakening(lab) :
                  add(usedPlots(lab) abs(plot))
               else:
                  add(plotAvailables(lab), abs(plot))
      clear(plots(lab))
      checkAutoWin(lab)
      false

defn determineFinalWinner (lab : Labyrinth) :
   gprintln("Determine Final Winner")
   var ir = getIslamResource(lab)
   var gr = getGoodResource(lab)
   var green = 0
   for country in c(countries(lab)) do:
      val name = key(country)
      if isGreenRegimeChange(lab, name):
         green  = green + getResource(lab, name)
   if scenario(lab) == "ISILHM":
      var cc = false
      let :
         label<False> break:
            for country in c(countries(lab)) do:
               val name = key(country)
               if isCaliphateCapital(lab, name):
                  ir = ir + 1
                  cc = true
                  break(false)
      if not cc:
         gr = gr + 2
   else if scenario(lab) == "Surge":
      val v = extract(
               lab, 
               fn (x:String) : getGovern(lab, x) == "islamrule" or isRegimeChange(lab, x),
               ["afghanistan" "iraq"]
            )
      if length(v) > 0:
         gprintln("Bonus +1 IR in %_ for %_ in Islamist Rule or Regime Change" % [scenario(lab) v])
         ir = ir + 1
   gprintln("Good Resource=%_" % [gr])
   gprintln("Islamic Resource=%_" % [ir])
   gprintln("Green Regime Change Resource=%_" % [green])
   if gr > (ir + green) * 2:
      set-winner(lab, "us")
      set-winMethod(lab, "GR > 2x (IR + Green RC)")
   else:
      set-winner(lab, "jihadist")
      set-winMethod(lab, "GR <= 2x (IR + Green RC)")
   gprintln("Winner is: %_" % [winner(lab)])
   set-finalWin(lab, true)

defn setAttr (lab: Labyrinth, name: String, attr: String, value: String|Int|True|False) -> True|False :
   val country = (c(countries(lab)))[name]
   match(country) :
      (country : Country) : 
         val attrs = attrs(country)
         val attr? = false when get?(attrs, attr, false) is False else true
         match(value):
            (f:False) : 
               if attr? :
                  remove(attrs, attr)
                  addCountryToCurrentPhase(lab, name)
                  true
               else:
                  false
            (v:Int) :
               if v == 0:
                  if attr? :
                     remove(attrs, attr)
                     addCountryToCurrentPhase(lab, name)
                     true
                  else :
                     false
               else :
                  attrs[attr] = value
                  addCountryToCurrentPhase(lab, name)
                  true
            (value) : 
               attrs[attr] = value
               addCountryToCurrentPhase(lab, name)
               attr?
         ; gprint(country)
      (country) : false

defn getAttr (lab: Labyrinth, name : String, attr: String) -> String|Int|True|False :
   val cc = c(countries(lab))
   ; gprintln("GetAttr: %_ %_" % [name attr])
   val country = get?(cc, name, false)
   match(country):
      (country : Country) :
         val value = get?(attrs(country), attr)
         match(value):
            (value : False): false
            (value) : value
      (f) : false

defn setPosture (lab : Labyrinth, name: String, posture : String) :
   if setAttr(lab, name, "posture", posture) :
      gprintln("%_ is %_. World=%_" % [name, getPosture(lab, name), getGWOTHard(lab)])
         
defn setGovern (lab : Labyrinth, name: String, govern : String) :
   setAttr(lab, name, "govern", govern)

defn improveGovern (lab : Labyrinth, name : String):
   val govern = getAttr(lab, name, "govern")
   switch {govern == _} :
      "poor" :
         setAttr(lab, name, "govern", "fair")
         disengagement(lab, name, "awaken")
      "fair" :
         toGood(lab, name)
      else : false

defn setAlign (lab : Labyrinth, name: String, align : String) :
   setAttr(lab, name, "align", align)
   if align == "adversary":
      removeAllAdvisors(lab, name)

defn addOneCell (lab: Labyrinth, name : String, reason : String, event: True|False ) -> String:
   ; check Cell Track
   var result = ""
   label<False> break :
      if reason == "recruit":
         if cellAvailable(lab, event) <= 0 :
            break(false)
      if isCaliphate(lab, name):
         val cell = getActiveCell(lab, name, false) + 1
         setActiveCell(lab, name, cell)
         gprintln("one active cell is added in %_ to %_" % [name cell])
         result = "activecell"
      else:
         val cell = getSleeperCell(lab, name, false) + 1
         setSleeperCell(lab, name, cell)
         gprintln("one sleeper cell is added in %_ to %_" % [name cell])
         result = "sleepercell"
      if reason != "travelto":
         removeCadre(lab, name)
      if reason == "recruit":
         if celltrack(lab) > 0:
            val cell = celltrack(lab) - 1
            set-celltrack(lab, cell)
         else:
            val cell = cellcamps(lab) - 1
            set-cellcamps(lab, cell)
      gprint(countries(lab)[name])
      testCountry(lab, name)
      addCountryToCurrentPhase(lab, name)
   result

defn setTroop (lab : Labyrinth, name : String, troop : Int) :
   label<False> break :
      if name == "track" :
         set-trooptrack(lab, troop)
         break(false)

      val country = countries(lab)[name]
      match(country):
         (country : Country) :
            if troop == 0:
               remove(attrs(country), "troop")
            else:
               setAttr(lab, name, "troop", troop)
               removeAllAdvisors(lab, name)
            addCountryToCurrentPhase(lab, name)
         (country) : false

defn setRegimeChange (lab : Labyrinth, name : String, color : String) :
   if setAttr(lab, name, "regimechange", color) :
      if color == "green" :
         connectCaliphate(lab, name)
      
defn setMarker (lab : Labyrinth, name : String, marker : String, value : String|True|Int) :
   if name == "markers" :
      add(markers(lab), marker)
   else :
      setAttr(lab, name, marker, value)

defn addOneAid (lab : Labyrinth, name : String, event: True|False) :
   label<False> break :
      var aid = getAid(lab, name)
      if aid >= 1 and event == false:
         break(false)
      aid = aid + 1
      setAttr(lab, name, "aid", aid)
      gprint("Aid=%_ in %_" % [aid name])

defn setBesiegedRegime (lab : Labyrinth, name : String) :
   setAttr(lab, name, "besiegedregime", true)

defn addCountryToCurrentPhase (lab : Labyrinth, name : String) :
   val cpc = currentphaseCountries(lab)
   val f = find(fn (x : String) : x == name, cpc)
   if f is False :
      add(cpc, name)

public defn getPosture (lab : Labyrinth, name : String) -> String :
   val posture = getAttr(lab, name, "posture")
   match(posture) :
      (posture : String) : posture
      (f) : "untested"

public defn getGWOTHard (lab : Labyrinth) :
   ; count hard as 1 and soft as -1
   var gwot = 0
   for country in c(countries(lab)) do:
      val name = key(country)
      if not (name == "us" or isMuslim(lab, name) or name == "iran"):
         val posture = getPosture(lab, name)
         if posture == "hard":
               gwot = gwot + 1
         else if posture == "soft":
               gwot = gwot - 1
   if gwot > 3:
      gwot = 3
   if gwot < (- 3):
      gwot = (- 3)
   gwot

defn removeAllAdvisors (lab : Labyrinth, name : String) :
   if setAttr(lab, name, "advisors", false) :
      gprintln("Remove All Advisors in %_" % [name])

defn cellAvailable (lab : Labyrinth, event: True|False) :
   var result = 0
   label<False> break:
      if event:
         result = celltrack(lab) + cellcamps(lab)
         break(false)
      var buildable = 0
      if funding(lab) <= 3:
         buildable = celltrack(lab) - 10
      else if funding(lab) <= 6:
         buildable = celltrack(lab) - 5
      else if funding(lab) <= 8:
         buildable = celltrack(lab)
      else if funding(lab) == 9:
         buildable = celltrack(lab) + cellcamps(lab)
      result = buildable
   result

public defn isCaliphate (lab : Labyrinth, name : String) -> True|False:
   val ic = getAttr(lab, name, "caliphate")
   match(ic):
      (ic:True) : ic
      (ic) : false

defn removeCaliphate (lab : Labyrinth, name : String) :
   setAttr(lab, name, "caliphate", false)
   
public defn getActiveCell (lab : Labyrinth, name : String, withMarkers: True|False) -> Int :
   var cell = 0
   val ac = getAttr(lab, name, "activecell")
   match(ac):
      (ac : Int) : cell = cell + ac
      (ac) : cell = cell
   if withMarkers:
      match( getAttr(lab, name, "sadr") ):
         (t : True) : cell = cell + 1
         (t) : cell = cell
   cell

defn setActiveCell (lab : Labyrinth, name : String, cell : Int) :
   setAttr(lab, name, "activecell", cell)
   
public defn getSleeperCell (lab : Labyrinth, name : String, withMarkers : True|False) -> Int:
   val sc = getAttr(lab, name, "sleepercell")
   match(sc):
      (sc:Int) : sc
      (f) : 0

defn getCell (lab : Labyrinth, name : String, includeMarkers : True|False) :
   getSleeperCell(lab, name, includeMarkers) + getActiveCell(lab, name, includeMarkers)
      
defn setSleeperCell (lab : Labyrinth, name : String, cell : Int) :
   setAttr(lab, name, "sleepercell", cell)

defn removeCadre (lab : Labyrinth, name : String) :
   if setAttr(lab, name, "cadre", false) :
      gprintln("Cadre removed in %_" % [name])

public defn isCadre (lab : Labyrinth, name : String) -> True|False :
   val cadre = getAttr(lab, name, "cadre")
   match(cadre):
      (c : True) : true
      (c) : false

defn testCountry (lab : Labyrinth, name : String) -> False :
   label<False> break:
      if not isUntested(lab, name):
         break(false)
      if isMuslim(lab, name):
         rollGovern(lab, name)
         setAlign(lab, name, "neutral")
         gprintln("%_ is a %_ %_" % [name getAlign(lab,name) getGovern(lab,name)])
      else:
         if name == "iran":
            break(false)
         rollPosture(lab, name, 0)

public defn getAlign (lab : Labyrinth, name : String) -> String :
   val a = getAttr(lab, name, "align")
   match(a):
      (a : String) : a
      (a) : "untested"

public defn getGovern (lab : Labyrinth, name : String) -> String|False :
   val g = getAttr(lab, name, "govern")
   match(g):
      (g: String) : g
      (g) : false

public defn isMuslim (lab : Labyrinth, name : String) -> True|False :
   val im = getAttr(lab, name, "muslim")
   match(im) :
      (im:True) : true
      (im) : false
      
public defn isUntested (lab : Labyrinth, name : String) -> True|False:
   if isMuslim(lab, name):
      match(getGovern(lab, name)):
         (f : False) : true
         (govern : String) :
            if empty?(govern) :
               true
            else:
               false
         (f) : true
   else:
      if getPosture(lab, name) == "untested":
         true
      else:
         false

public defn getAid (lab : Labyrinth, name : String) :
   val a = getAttr(lab, name, "aid")
   match(a):
      (a : Int) : a
      (a) : 0

defn rollGovern (lab : Labyrinth, name : String) :
   val die = rollOnce(lab)
   if die <= 4:
      setGovern(lab, name, "poor")
   else:
      setGovern(lab, name, "fair")
   gprintln("Country %_ is %_" % [name getGovern(lab,name)])

defn rollPosture (lab : Labyrinth, name : String, drm:Int) :
   gprint("Roll Posture for %_ " % [name])
   var die = rollOnce(lab) + drm
   if name == "us":
      die = die + 1
   if die <= 4:
      gprintln("soft")
      setPosture(lab, name, "soft")
   else:
      gprintln("hard")
      setPosture(lab, name, "hard")

defn rollOnce (lab : Labyrinth) :
   val dice = rand(6) + 1
   gprintln("Rolled: %_" % [dice])
   dice

defn connectCaliphate (lab : Labyrinth, name : String) :
   var region = adjacentRegion(lab, [name])
   region = extract(lab, fn (x : String) : isCaliphate(lab, x), region)
   if length(region) > 0:
      setCaliphateCountry(lab, name)

defn adjacentRegion (lab : Labyrinth, origins : Tuple<String>) -> Tuple<String> :
   val adjs = to-vector<String>(origins)
   for country in c(countries(lab)) do :
      val name = key(country)
      if not contains?(origins, name):
         label<False> break:
            for c in origins do:
               if isAdjacent(lab, name, c, false):
                  add(adjs, name)
                  break(false)
   to-tuple(adjs)

defn isAdjacent (lab : Labyrinth, fromname : String, toname : String, travel : True|False) :
   label<True|False> return:
      if fromname == toname:
         return(true)
      if contains?(schengens, fromname) and contains?(schengens, toname) and not (contains?(lapsing(lab), 169) and travel):
         return(true)
      if isMarker(lab, "gulfstates", "qataricrisis"):
         val gang = ["iran", "gulfstates", "saudiarabia", "yemen"]
         if contains?(gang, fromname) and contains?(gang, toname) :
               return(true)

      for route in routes(lab) do:
         val src = route[0]
         val dst = route[1]
         if src == fromname and dst == toname:
               return(true)
         else if src == toname and dst == fromname:
               return(true)

         ; one in schengens
         if contains?(schengens, fromname):
               if src == toname and dst == "schengen" and not (contains?(lapsing(lab), 169) and travel):
                  return(true)
               if dst == toname and src == "schengen":
                  return(true)
         if contains?(schengens, toname):
               if src == fromname and dst == "schengen" and not (contains?(lapsing(lab), 169) and travel):
                  return(true)
               if dst == fromname and src == "schengen":
                  return(true)
      return(false)

public defn isMarker (lab : Labyrinth, name : String, marker : String) :
   if name == "markers":
      contains?(markers(lab), marker)
   else:
      val result = getAttr(lab, name, marker)
      match(result):
         (result:False) : false
         (result) : true

defn removeMarker (lab : Labyrinth, name : String, marker : String, value : True|Int):
   match(value):
      (value:True) :
         if name == "markers":
            remove-item(markers(lab), marker)
         else:
            setAttr(lab, name, marker, false)
      (value:Int) :
         var a = getMarker(lab, name, marker)
         match(a) :
            (a : Int) :
               var b = a
               b = b - 1
               if b == 0:
                  if name == "markers":
                     remove-item(markers(lab), marker)
                  else:
                     setAttr(lab, name, marker, false)
               else:
                     setMarker(lab, name, marker, b)

defn getMarker (lab : Labyrinth, name : String, marker : String) -> True|False|Int :
   if name == "markers":
      contains?(markers(lab), marker)
   else :
      val attr = getAttr(lab, name, marker)
      match(attr):
         (attr:True|False|Int) : attr
         (attr) : false

defn setCaliphateCountry (lab : Labyrinth, name : String) :
   setAttr(lab, name, "caliphate", "country")
   gprint("%_ becomes Caliphate Country" % [name])

defn setCaliphateCapital (lab : Labyrinth, name : String) :
   setAttr(lab, name, "caliphate", "capital")
   gprint("%_ becomes Caliphate Capital" % [name])

public defn isCaliphateCapital (lab : Labyrinth, name : String) :
   val value = getAttr(lab, name, "caliphate")
   match(value) :
      (value : String) : if value == "capital" : true
      (value) : false
      
defn extract (lab : Labyrinth, func : String -> True|False, candidates : Tuple<String>|False) :
   to-tuple{_} $ filter( 
      { val name = _ ( func(name) and not (isMarker(lab, name, "truce") and not mayEndTruce(lab, name)) ) }
      seq( { key(_) } c(countries(lab)) ) when candidates is False else to-seq(candidates as Tuple<String>)
   )

defn mayEndTruce (lab : Labyrinth, name : String) -> True|False :
   label<True|False> return:
      if not isMarker(lab, name, "truce"):
         return(true)
      val resources = getResource(lab, name)

      if currentplayer(lab) == "us" and prestige(lab) > resources or currentplayer(lab) == "jihadist" and funding(lab) > resources:
         val comm = comm(lab)
         match(comm):
            (comm:Communicator) :
               val ans = queryGeneric(comm, currentplayer(lab), to-string("End Truce in %_?"%[name]), ["y", "n"], "endtruce",
                                             [to-string("Yes, end Truce in %_" % [name]), "No"], false, false )
               if ans == "y":
                  if currentplayer(lab) == "us":
                     changePrestige(lab, (- resources))
                  else:
                     changeFunding(lab, (- resources))
                  removeMarker(lab, name, "truce", true)
                  remove(lapsing(lab), 239)
                  return(true)
      else:
         return(false)

defn getResource (lab : Labyrinth, name : String) -> Int :
   val country = c(countries(lab))[name]
   match(country):
      (country: Country) :
         val attrs = attrs(country)
         var resources = attrs["resource"]
         match(resources) :
            (r : Int) :
               if isCaliphateCapital(lab, name):
                     resources = resources + 1
               if contains?(lapsing(lab), 356) and isOil(lab, name):
                     resources = resources - 1
               if contains?(lapsing(lab), 117) and isOil(lab, name):
                     resources = resources + 1
               if contains?(lapsing(lab), 118) and isOil(lab, name):
                     resources = resources + 1
               if contains?(lapsing(lab), 236) and isOil(lab, name):
                     resources = resources + 1
               if contains?(lapsing(lab), 289):
                     val gang = ["iran", "iraq", "gulfstates", "saudiarabia"]
                     if contains?(gang, name):
                        resources = resources - 1
                     else if isOil(lab, name):
                        resources = resources + 1
               if resources < 0: resources = 0
               resources
            (resources) : 0
      (f) : 0

defn isOil (lab : Labyrinth, name : String) -> True|False :
   val oil = getAttr(lab, name, "oil")
   match(oil):
      (oil:False) : false
      (oil) : true

defn changeFunding (lab : Labyrinth, inc : Int) :
   val oFunding = funding(lab)
   set-funding(lab, funding(lab) + inc)
   if funding(lab) > 9 :
      set-funding(lab, 9)
   if funding(lab) < 1 :
      set-funding(lab, 1)
   gprint("Change Funding from %_ by %_ to %_" % [oFunding, inc, funding(lab)])

defn changePrestige (lab : Labyrinth, inc : Int) :
   val oPrestige = prestige(lab)
   set-prestige(lab, prestige(lab) + inc)
   if prestige(lab) > 12 :
      set-prestige(lab, 12)
   if prestige(lab) < 1 :
      set-prestige(lab, 1)
   gprintln("Change Prestige from %_ by %_ to %_" % [oPrestige inc prestige(lab)])

public defn getGoodResource (lab : Labyrinth):
   var resources = 0
   val validCountries = extract(lab, fn (x : String) : isMuslim(lab, x) and getGovern(lab, x) == "good", false)
   for name in validCountries do:
      resources = resources + getResource(lab, name)
   resources

public defn getIslamResource (lab : Labyrinth) :
   var resources = 0
   val validCountries = extract( lab,
      fn (x : String) : isMuslim(lab, x) and (getGovern(lab, x) == "islamrule" or isCaliphateCapital(lab, x)), 
      false)
   for name in validCountries do:
      if getGovern(lab, name) == "islamrule":
            resources = resources + getResource(lab, name)
      else:
            resources = resources + 1
   resources

public defn getFGC (lab : Labyrinth) -> Int:
   var count : Int = 0
   for country in c(countries(lab)) do:
      val name = key(country)
      val muslim = getAttr(lab, name, "muslim")
      if muslim is True:
         val govern = getAttr(lab, name, "govern")
         if govern is String :
            if govern == "good" or govern == "fair":
               count = count + 1
      
   count

defn isSchengen (lab : Labyrinth, name : String) -> True|False :
   contains?(schengens, name)

public defn getPIC (lab : Labyrinth) -> Int :
   var count : Int = 0
   for country in c(countries(lab)) do :
      val name = key(country)
      if getAttr(lab, name, "muslim") is True :
         val govern = getAttr(lab, name, "govern")
         if govern is String :
            if govern == "poor" or govern == "islamrule":
               count = count + 1
   count

public defn getTroopLevel (lab : Labyrinth) -> String :
   label<String> return :
      if trooptrack(lab) >= 10:
         return("low")
      else if trooptrack(lab) >= 5:
         return("war")
      else:
         return("overstretch")

defn getCellOnMap (lab : Labyrinth) -> Int:
   var cell = 0
   for country in c(countries(lab)) do :
      val name = key(country)
      val sleepercell = getAttr(lab, name, "sleepercell")
      match(sleepercell):
         (s:Int) : 
            if s > 0 : 
               cell = cell + s
         (s) : cell
      val activecell = getAttr(lab, name, "activecell")
      match(activecell):
         (a:Int) :
            if a > 0: (cell = cell + a)
         (a) : cell
   cell

defn countAwaken (lab : Labyrinth) -> Int:
   var awaken = 0
   for country in c(countries(lab)) do :
      val name = key(country)
      awaken = awaken + getAwaken(lab, name)
   awaken

defn countReact (lab : Labyrinth) -> Int:
   var react = 0
   for country in c(countries(lab)) do :
      val name = key(country) 
      react = react + getReact(lab, name)
   react

public defn getAwaken (lab : Labyrinth, name : String) -> Int:
   val awaken = getAttr(lab, name, "awaken")
   match(awaken) :
      (awaken : Int) : awaken
      (awaken) : 0
   
public defn getReact (lab : Labyrinth, name : String) -> Int:
   val react = getAttr(lab, name, "react")
   match(react) :
      (react : Int) : react
      (react) : 0

defn shuffleDeck (lab : Labyrinth) :
   val newdeck = Vector<Int>()
   if decks(lab) is-not False :
      for d in decks(lab) as Tuple<Tuple<Int>> do:
         val d-v = to-vector<Int>(d)
         while length(d-v) > 0 :
            var index = rand(length(d-v))
            val card = get(d-v, index)
            remove(d-v, index)
            add(newdeck, card)
      clear(deck(lab))
      add-all(deck(lab), loadedDeck(lab))
      add-all(deck(lab), newdeck)

defn dealHands (lab : Labyrinth) :
   var reshuffled = false
   val [j, u] = getCardDraw(lab)
   var toJihadist : Int = j as Int
   var toUS : Int = u as Int
   while toJihadist > 0 or toUS > 0:
      if toJihadist > 0:
            reshuffled = reshuffled or drawOneCard(lab, "jihadist")
            toJihadist = toJihadist - 1
      if toUS > 0:
            reshuffled = reshuffled or drawOneCard(lab, "us")
            toUS = toUS - 1
   gprintln("JihadistHand=%_" % [jihadisthand(lab)])
   gprintln("USHand=%_" % [ushand(lab)])
   gprintln("Deck=%_" % [deck(lab)])
   gprintln("NumberOfDecks=%_" % [nbDeck(lab)])
   reshuffled

defn getCardDraw (lab : Labyrinth) :
   var toUS = 9
   var toJihadist = 9
   switch { getTroopLevel(lab) == _ } :
      "low" : toUS = 9
      "war" : toUS = 8
      else  : toUS = 7
   switch { funding(lab) <= _ } :
      3 : toJihadist = 7
      6 : toJihadist = 8
      else : toJihadist = 9
   if contains?(lapsing(lab), 273) :
      gprintln("US draws two more cards")
      toUS = toUS + 2
   [toJihadist, toUS]

defn drawOneCard (lab : Labyrinth, player : String) :
   label<True|False> return:
      var reshuffled = false
      if length(deck(lab)) == 0:
         reshuffleDeck(lab)
         reshuffled = true
         set-reshuffled(lab, true)
      if length(deck(lab)) == 0:
         gprintln("No cards in Deck")
         return(true)
      val card = deck(lab)[0]
      remove(deck(lab), 0)
      if not awakening(lab) and scenario(lab) == "Surge" and card > 120:
         set-awakening(lab, true)
         setAttr(lab, "syria", "sunni", false)
         c(countries(lab))["mali"] = awakenBoard["mali"]
         c(countries(lab))["nigeria"] = awakenBoard["nigeria"]
         for route in awakenRoutes do :
            val result = find( fn ( x : [String,String], y : [String,String] ) -> True|False : (
                                 if ( x[0] == y[0] and x[1] == y[1] ) or ( x[0] == y[1] and x[1] == y[0] ) :
                                    true
                                 else :
                                    false )
                                 routes(lab)
                                 [route] )
            match(result) : 
               (result:False) : add(routes(lab), route)
               (result) : result
         convergence(lab, "awaken")
      gprintln("Card %_ is dealt to %_" % [card player])
      if player == "us":
         val original = to-vector<Int>([card])
         add-all(original, ushand(lab))
         clear(ushand(lab))
         add-all(ushand(lab), original)
      else:
         val original = to-vector<Int>([card])
         add-all(original, jihadisthand(lab))
         clear(jihadisthand(lab))
         add-all(jihadisthand(lab), original)
      reshuffled

defn reshuffleDeck (lab : Labyrinth) :
   gprintln("Reshuffle Deck")
   clear(deck(lab))
   add-all(deck(lab), discard(lab))
   clear(discard(lab))
   val newdeck = Vector<Int>()
   while length(deck(lab)) > 0 :
      val index = rand(length(deck(lab)))
      val card = get(deck(lab), index)
      add(newdeck, card)
      remove(deck(lab), index)
   add-all(deck(lab), newdeck)

defn isPirates (lab : Labyrinth) -> True|False :
   if not isMarker(lab, "markers", "pirates"):
      false
   else if getGovern(lab, "somalia") == "islamrule" or getGovern(lab, "yemen") == "islamrule":
      true
   else :
      false

defn checkAutoWin (lab : Labyrinth) -> True|False :
   gprintln("Check AutoWin")
   val ir = getIslamResource(lab)
   if ir >= 6:
      gprintln("Islamic Resource=%_" % [ir])
      ; check adjacency
      if jihadistplayer(lab) == "bot":
            set-gameend(lab, true)
            set-winner(lab, "jihadist")
            set-winMethod(lab, "IR >= 6")
            true
   false

defn flipRegimeChange (lab : Labyrinth):
   for country in c(countries(lab)) do:
      val name = key(country)
      if isRegimeChange(lab, name):
            setRegimeChange(lab, name, "tan")

defn isRegimeChange (lab : Labyrinth, name : String) -> True|False:
   val color = getAttr(lab, name, "regimechange")
   match(color):
      (color:String) : true
      (color) : false

public defn isGreenRegimeChange (lab : Labyrinth, name : String) -> True|False :
   val rc = getAttr(lab, name, "regimechange")
   match(rc):
      (rc : String) : true when rc == "green" else false
      (rc) : false   

public defn isTanRegimeChange (lab : Labyrinth name : String) -> True|False :
   isRegimeChange(lab name) and not isGreenRegimeChange(lab name)

public defn isSunni (lab : Labyrinth, name : String) -> True|False :
   match(getAttr(lab, name "sunni")) :
      (f : False) : false
      (t) : true

public defn isShia (lab : Labyrinth, name : String) -> True|False :
   isMuslim(lab name) and not isSunni(lab name)     

defn findTrainingCamps (lab : Labyrinth) -> String|False :
   val validCountries = extract(lab, fn (x:String) : isMarker(lab, x, "trainingcamps"), false)
   if length(validCountries) == 0:
      false
   else:
      validCountries[0]

defn checkTrainingCamps (lab : Labyrinth) :
   val name = findTrainingCamps(lab)
   var newCell = 0
   match(name):
      (name : String) :
         if getCell(lab, name, true) == 0 and not isCadre(lab, name):
            removeTrainingCamps(lab, name)
         else :
            if isCaliphate(lab, name) and maxcamps(lab) == 3:
               set-maxcamps(lab, 5)
               newCell = 2
               while lesscell(lab) > 0 and newCell > 0:
                  set-lesscell(lab, lesscell(lab) - 1)
                  newCell = newCell - 1
               set-cellcamps(lab, cellcamps(lab) + newCell)
            else if not isCaliphate(lab, name) and maxcamps(lab) == 5:
               set-maxcamps(lab, 3)
               newCell = 2
               while cellcamps(lab) > 0 and newCell > 0:
                  set-cellcamps(lab, cellcamps(lab) - 1)
                  newCell = newCell - 1
               set-lesscell(lab, lesscell(lab) + newCell)
      (name) : newCell = 0

defn removeTrainingCamps (lab : Labyrinth, name : String) :
   if isMarker(lab, name, "trainingcamps"):
      val lessCell = maxcamps(lab) - cellcamps(lab)
      set-maxcamps(lab, 0)
      set-cellcamps(lab, 0)
      set-lesscell(lab, lesscell(lab) + lessCell)
      gprintln("Remove Training Camps in %_ lessCell=%_" % [name lesscell(lab)])
      removeMarker(lab, name, "trainingcamps", true)

defn countIRCountries (lab : Labyrinth) :
   var count = 0
   for country in c(countries(lab)) do:
      val name = key(country)
      if getGovern(lab, name) == "islamrule":
            count = count + 1
   count

      
; todo: implement later
defn convergence (lab : Labyrinth, who : String) -> False :
   gprint("convergence not implemented")
   false
   
   ; if not self.awakening:
   ;    return
   ; gprint("Convergence")
   ; gprint('Tan dr', end=' ')
   ; tan = self.rollOnce()
   ; gprint('Black dr', end=' ')
   ; black = self.rollOnce()
   ; black = (black + 1) // 2
   ; if tan == 1 and black == 3:
   ;    # special case, use table2
   ;    while True:
   ;          gprint('Use Random Muslim Country Table 2')
   ;          die = self.rollOnce()
   ;          country = self.random_muslim_country2[die - 1]
   ;          gprint(f'Rolled country={country}')
   ;          # test iraq and nigeria cases
   ;          if country == 'iraq' or country == 'nigeria':
   ;             if not self.canAwakeReact(country):
   ;                continue
   ;          break
   ; else:
   ;    # normal case
   ;    country = self.random_muslim_country[tan - 1][black - 1]
   ;    gprint(f'Rolled country={country}')
   ; # country established
   ; if not self.canAwakeReact(country):
   ;    adjCountries = self.findAdjacentCountries(country)
   ;    # remove countries not eligible
   ;    for adj in adjCountries:
   ;          if not self.canAwakeReact(adj):
   ;             adjCountries.remove(adj)
   ;    if len(adjCountries) == 0:
   ;          return
   ;    gprint(f"Random Pick from these Countries:{adjCountries}")
   ;    country = self.randomPick(adjCountries)
   ;    gprint(f'Randomly picked country={country}')
   ; # finally a valid country is found
   ; if who == 'awaken':
   ;    self.setAwaken(country, self.getAwaken(country) + 1)
   ; elif who == 'react':
   ;    self.setReact(country, self.getReact(country) + 1)
   ; gprint(self.countries[country])

; todo
defn polarization (lab : Labyrinth) :
   gprintln("polarization not implemented")
   false
   
; todo
defn attrition (lab : Labyrinth) :
   gprintln("attrition not implemented")
   false

; todo
defn disengagement (lab : Labyrinth, name : String, who : String) :
   gprintln("disengagement not implemented")
   false

defn doDiscard (lab : Labyrinth, card-id : Int) :
   if card-id == 200:
      ; special handling
      val pos : Int = length(deck(lab)) / 2
      val f = cat-all([deck(lab)[0 to pos] [card-id] deck(lab)[pos to false]])
      clear(deck(lab))
      add-all(deck(lab), f)
      gprintln("Card %_ is inserted in position:%_" % [card-id pos])
      gprintln(deck(lab))
   else :
      add(discard(lab), card-id)

defn getTroopStrength (lab : Labyrinth, name : String, forPrestige : True|False) -> Int :
   var troop = getTroop(lab, name)
   if name != "track" :
      val nato = getAttr(lab, name, "nato")
      match(nato):
         (nato : Int):
            troop = troop + 2 * nato
         (nato) : false
      if not forPrestige :
         val unscr1973 = getAttr(lab, name, "unscr1973")
         match(unscr1973):
            (un : Int) :
               troop = troop + un
            (un) : false
   ; gprintln("Total Strength=%_" % [troop])
   troop

public defn getMilitia (lab : Labyrinth, name : String) -> Int :
   val militia = getAttr(lab, name, "militia")
   match(militia):
      (m : Int) : m
      (m) : 0

public defn getTroop (lab : Labyrinth, name : String) -> Int :
   label<Int> return:
      if name == "track" :
         return(trooptrack(lab))
      val troop = getAttr(lab, name, "troop")
      match(troop):
         (troop: Int) : troop
         (troop) : 0

; this is for travel from. No cadre
defn removeOneCell (lab : Labyrinth, fromname : String) :
   var result : String = ""
   val activeCell = getActiveCell(lab, fromname, false)
   if activeCell > 0:
      setActiveCell(lab, fromname, activeCell - 1)
      result = "activecell"
   else:
      val sleeperCell = getSleeperCell(lab, fromname, false)
      if sleeperCell > 0:
         setSleeperCell(lab, fromname, sleeperCell - 1)
         result = "sleepercell"
   result

defn removeOneActiveCellToTrack (lab : Labyrinth, name : String) :
   val activecell = getAttr(lab, name, "activecell")
   match(activecell):
      (a : Int) :
         if a > 0:
            val cell = a - 1
            if cell > 0:
               setAttr(lab, name, "activecell", cell)
            else:
               setAttr(lab, name, "activecell", false)
            if lesscell(lab) > 0:
               set-lesscell(lab, lesscell(lab) - 1)
            else if cellcamps(lab) < maxcamps(lab) :
               set-cellcamps(lab, cellcamps(lab) + 1)
            else:
               set-celltrack(lab, celltrack(lab) + 1)
      (a) :
         if isMarker(lab, name, "sadr") :
            removeMarker(lab, name, "sadr", true)
            gprintln("Sadr is removed in %_" % [name])

defn calNeed (lab : Labyrinth, sels : Seqable<String>) -> Tuple<[String, Int]> :
   val selections = Vector<[String, Int]>()
   for name in sels do:
      val need = getGovernNum(lab, name)
      add(selections, [name, need] )
   to-tuple(selections)

defn getRecruitNum (lab : Labyrinth, name : String) -> Int :
   label<Int> return :
      if isCivilWar(lab, name) or isRegimeChange(lab, name) or isMarker(lab, name, "trainingcamps"):
         return(6)
      val recruit = getAttr(lab, name, "recruit")
      match(recruit):
         (r : Int): return(r)
         (r): getGovernNum(lab, name)

defn getGovernNum (lab : Labyrinth, name : String) -> Int :
   val govern = getGovern(lab, name)
   match(govern):
      (g: String) :
         switch {g == _} :
            "islamrule": 6
            "poor" : 3
            "fair" : 2
            "good" : 1
            else :   0
      (g) : 0

public defn isCivilWar (lab : Labyrinth, name : String) -> True|False :
   val civilwar = getAttr(lab, name, "civilwar")
   match(civilwar):
      (c:False) : false
      (c) : true

defn shiftAlign (lab : Labyrinth, name : String, align : String) :
   gprintln("Shift Alignment towards %_ in %_" % [ align name])
   var cur = getAlign(lab, name)
   if align == "ally":
      if cur == "adversary":
            cur = "neutral"
      else if cur == "neutral":
            cur = "ally"
   else if align == "adversary":
      if cur == "ally":
            cur = "neutral"
      else if cur == "neutral":
            cur = "adversary"
            removeAllAdvisors(lab, name)
   if cur != "untested":
      setAlign(lab, name, cur)
   gprintln("Alignment of %_ is %_" % [name getAlign(lab, name)] )

defn worsenGovern (lab : Labyrinth, name : String, canIR : True|False) :
   val govern = getAttr(lab, name, "govern")
   match(govern):
      (g: String) :
         switch {g == _} :
            "good" : 
               setAttr(lab, name, "govern", "fair")
               disengagement(lab, name, "react")
            "fair" :
               setAttr(lab, name, "govern", "poor")
               disengagement(lab, name, "react")
            "poor" :
               if canIR: toIslamrule(lab, name)
      (g) : false

defn removeOneAid (lab : Labyrinth, name : String) :
   val aid = getAttr(lab, name, "aid")
   match(aid) :
      (aid : Int) :
         switch { aid > _ } :
            1 : setAttr(lab, name, "aid", aid - 1)
            else : setAttr(lab, name, "aid", false)
         gprintln("Remove One Aid to %_" % [aid])
      (aid) : false

defn toGood (lab : Labyrinth, name : String) :
   setAttr(lab, name, "govern", "good")
   setAwaken(lab, name, 0)
   setReact(lab, name, 0)
   removeTrainingCamps(lab, name)
   removeMarkers(lab, name, ["regimechange", "besiegedregime", "aid"])
   convergence(lab, "awaken")
   if isCivilWar(lab, name) :
      endCivilWar(lab, name)
   while getMilitia(lab, name) > 0:
      removeOneMilitia(lab, name)
   if isCaliphateCapital(lab, name):
      ; remove capital
      removeCaliphate(lab, name)
      ; move capital to adjacent
      val candidates = Vector<String>()
      for other-country in c(countries(lab)) do:
         val other = key(other-country)
         if isAdjacent(lab, name, other, false) and isCaliphate(lab, other) :
            add(candidates, other)
      if length(candidates) > 0:
         changePrestige(lab, 1)
         changeFunding(lab, (- 1))
         if length(candidates) > 1:
         val capital = (
            queryCountry(comm(lab) as Communicator, "jihadist", "Choose new Caliphate Capital", to-tuple(candidates), "caliphatecapital", false) when
            length(candidates) > 1 else candidates[0]
         ) as String
         setCaliphateCapital(lab, capital)
         gprintln("New Caliphate Capital in %_" % [capital])
         ; remove isolated Caliphate
         val caliphates = to-vector<String>([capital])
         var join : True|False = true
         while join:
            join = false
            for c-country in c(countries(lab)) do:
               label<False> continue :
                  val c = key(c-country)
                  if contains?(caliphates, c) :
                     continue(false)
                  if isCivilWar(lab, c) or isRegimeChange(lab, c) or getGovern(lab, c) == "islamrule":
                     label<False> break :
                        for d in caliphates do:
                           if isAdjacent(lab, c, d, false):
                              add(caliphates, c)
                              setCaliphateCountry(lab, c)
                              gprintln("Caliphates %_" % [caliphates])
                              join = true
                              break(false)
         ; List caliphates estalished
         ; remove anyone marked but no in the List
         for c-country in c(countries(lab)) do :
            val c = key(c-country)
            if isCaliphate(lab, c) and not contains?(caliphates, c):
               removeCaliphate(lab, c)
               gprintln("Remove Caliphate in %_" % [c])
      else:
         changePrestige(lab, 2)
         changeFunding(lab, (- 2))
         gprintln("Cannot place Caliphate Capital")
   else if isCaliphate(lab, name) :
      removeCaliphate(lab, name)
      gprintln("Remove Caliphate Country")

defn toIslamrule (lab : Labyrinth, name : String) :
   setAttr(lab, name, "govern", "islamrule")
   setAlign(lab, name, "adversary")
   setAwaken(lab, name, 0)
   setReact(lab, name, 0)
   removeAllAdvisors(lab, name)
   removeMarkers(lab, name, ["besiegedregime", "regimechange", "aid"])
   if getArsenal(lab, name) > 0:
      val wmd = getArsenal(lab, name)
      for i in 0 to wmd do:
         add(plotAvailables(lab), "w")
      setArsenal(lab, name, 0)
   convergence(lab, "react")
   if isCivilWar(lab, name):
      endCivilWar(lab, name)
   while getMilitia(lab, name) > 0:
      removeOneMilitia(lab, name)
   connectCaliphate(lab, name)

defn removeOneMilitia (lab : Labyrinth, name : String):
   val m = getMilitia(lab, name)
   if m > 0:
      setMilitia(lab, name, m - 1)

defn setMilitia (lab : Labyrinth, name : String, m : Int):
   switch { m == _ } :
      0 : setAttr(lab, name, "militia", false)
      else : 
         setAttr(lab, name, "militia", m)
         testCountry(lab, name)
   
public defn getArsenal (lab : Labyrinth, name : String) :
   val arsenal = getAttr(lab, name, "arsenal")
   match(arsenal):
      (a : Int) : a
      (a) : 0

defn setArsenal (lab : Labyrinth, name : String, arsenal : Int):
   switch { arsenal == _ } :
      0 : setAttr(lab, name, "arsenal", false)
      else : setAttr(lab, name, "arsenal", arsenal)

defn endCivilWar (lab : Labyrinth, name : String):
   setAttr(lab, name, "civilwar", false)
   setMilitia(lab, name, 0)
   removeAllAdvisors(lab, name)
   removeUNSCR1973(lab, name)

defn setAwaken (lab : Labyrinth, name : String, awaken : Int):
   label<False> return :
      if awaken > 0:
         if not isMuslim(lab, name) or isCivilWar(lab, name) or getGovern(lab, name) == "good" or getGovern(lab, name) == "islamrule":
               return(false)

      switch { awaken == _ } :
         0 : setAttr(lab, name, "awaken", false)
         else : setAttr(lab, name, "awaken", awaken)
      testCountry(lab, name)

defn setReact (lab : Labyrinth, name : String, react : Int ) :
   label<False> return :
      if react > 0:
         if not isMuslim(lab, name) or isCivilWar(lab, name) or getGovern(lab, name) == "good" or getGovern(lab, name) == "islamrule":
               return(false)

      switch { react == _ } :
         0 : setAttr(lab, name, "react", false)
         else : setAttr(lab, name, "react", react)
      testCountry(lab, name)
    
defn removeUNSCR1973 (lab : Labyrinth, name : String):
   setAttr(lab, name, "unscr1973", false)
   
public defn isBesiegedRegime (lab : Labyrinth, name : String) -> True|False :
   val br = getAttr(lab, name, "besiegedregime")
   match(br):
      (br : False) : false
      (br) : true

defn removeMarkers (lab : Labyrinth, name : String, markers : Tuple<String> ):
   for marker in markers do :
      setAttr(lab, name, marker, false)

defn selectAndActivate (lab : Labyrinth, type : String, ops : Int, reason : String) -> Tuple<String>|False:
   label<False|Tuple<String>> return :
      gprintln("selectAndActivate:%_ %_" % [type ops])
      val selections = Vector<String>()
      ;var cell = 0
      label<False> break:
         while length(selections) < ops:
            var validCountries = extract(lab, fn (x) : getCell(lab, x, true) > 0 and (
                     type == "p" or (type != "p" and isMuslim(lab, x) and getGovern(lab, x) != "islamrule")), false)
            if type == "m":
                  validCountries = extract( lab,
                     fn (x): getCell(lab, x, true) - (getTroopStrength(lab, x, false) + getMilitia(lab, x)) >= 5, validCountries)
            val candidates = Vector<String>()
            for name in validCountries do:
               var cell = getCell(lab, name, true)
               for selection in selections do:
                  if selection == name:
                     cell = cell - 1
               if cell > 0:
                  add(candidates, name)
            ; candidates established
            if length(candidates) <= 0:
               return(false)
            val name? = queryCountry(comm(lab) as Communicator, "jihadist", "In which country?", to-tuple(candidates), reason, false)
            if name? is False:
               break(false)
            val name = name? as String
            add(selections, name)
            gprintln("selections=%_" % [selections])
      ; activate enough cells
      val temp = HashTable<String, Int>()
      for selection in selections do:
         if get?(temp, selection) is False:
            temp[selection] = 1
         else:
            temp[selection] = temp[selection] + 1
      for t in temp do:
         val name = key(t)
         val value = value(t)
         gprint("In %_ " % [name])
         if type == "m":
            val inc = getSleeperCell(lab, name, false)
            if inc > 0:
               setSleeperCell(lab, name, 0)
               setActiveCell{lab, name, _} $ getActiveCell(lab, name, false) + inc
         else:
            val new-value = max{0, _} $ {value - _} $ getActiveCell(lab, name, true)
            gprintln("flip %_ cells" % [new-value])
            ; flip that many cells
            if new-value > 0:
               setSleeperCell(lab, name, getSleeperCell(lab, name, false) - new-value)
               setActiveCell(lab, name, getActiveCell(lab, name, false) + new-value)
         gprint(c(countries(lab))[name])
      to-tuple(selections)

defn countRCCountries (lab : Labyrinth) -> Int:
   count( { isRegimeChange(lab, key(_)) } c(countries(lab)) )
   
defn switchPosture (lab : Labyrinth, name : String) :
   val pos = getPosture(lab, name)
   match(pos) :
      (pos : String) :
         switch { pos == _ } :
            "hard" : setPosture(lab, name, "soft")
            "soft" : setPosture(lab, name, "hard")
            else : false
      (pos) : false

defn isPermPosture (lab : Labyrinth, name : String) -> True|False :
   val perm = getAttr(lab, name, "permposture")
   match(perm):
      (perm : False) : false
      (perm) : true

defn rollPrestige (lab : Labyrinth) :
   gprint("Roll for Prestige. Currently Prestige=%_" % [prestige(lab)])
   val die = rollOnce(lab) + (max{_, -1} $ getGWOTPenalty(lab))
   var shift : Int = min(rollOnce(lab), rollOnce(lab))
   shift = ((- shift) when die <= 4 else shift)
   changePrestige(lab, shift)

defn getGWOTPenalty (lab : Labyrinth) -> Int :
   val gwot = getGWOTHard(lab)
   max{-3, _} $ min{0, _} $ (gwot when getPosture(lab, "us") == "hard" else (- gwot))

defn hasUSHand3Op (lab : Labyrinth) -> True|False :
   any?( {val [ops, assoc, title] = getCardInfo(_) ops == 3} ushand(lab) )

defn getWoiDRM (lab : Labyrinth, name : String, ignoreGWOT : True|False) -> Int :
   val toGood = 1 when getGovern(lab, name) == "fair" and getAlign(lab, name) == "ally" else 0
   gprint("to Good = %_ " % [toGood])
   val gwot = getGWOTPenalty(lab) when not ignoreGWOT else 0
   gprint("GWOT Penalty %_ " % [gwot])
   val prestigeDRM = getPrestigeDRM(lab)
   gprint("PrestigeDRM=%_ " % [prestigeDRM])
   val aid = getAid(lab, name)
   gprint("Aid=%_ " % [aid])
   val adjGoodAllyDRM = (1 when any?( { val a = key(_) isMuslim(lab, a) and getGovern(lab, a) == "good" and getAlign(lab, a) == "ally" and isAdjacent(lab, name, a, false) }
         c(countries(lab))
      ) else 0)
   gprint("Adjacent to Good Ally DRM=%_ " % [adjGoodAllyDRM])
   val awaken = getAwaken(lab, name)
   gprint("Awakening=%_ " % [awaken])
   val react = getReact(lab, name)
   gprint("Reaction=%_ " % [react])
   val drm = (- toGood) + gwot + prestigeDRM + aid + adjGoodAllyDRM + awaken - react
   gprintln("Final DRM=%_" % [drm])
   gprintln("War of Ideas DRM=%_ in %_" % [drm name])
   drm

defn getPrestigeDRM (lab : Labyrinth) -> Int :
   switch { prestige(lab) <= _ } :
      3 : -1
      6 : 0
      9 : 1
      else : 2

defn setCadre (lab : Labyrinth, name : String) :
   setAttr(lab, name, "cadre", true)
   gprintln("Cadre is placed in %_" % [name])

public defn getAdvisors (lab : Labyrinth name : String) -> Int :
   match(getAttr(lab name "advisors")) :
      (i : Int) : i
      (i : True) : 1
      (f) : 0

public defn isAdvisors (lab : Labyrinth, name : String) -> True|False :
   match(getAttr(lab, name, "advisors")) :
      (a : False) : false
      (a) : true

public defn getNATO (lab : Labyrinth name : String) -> Int :
   match(getAttr(lab name "nato")) :
      (a : Int) : a
      (f) : 0

public defn isUNSCR1973 (lab : Labyrinth name : String) -> True|False :
   match(getAttr(lab name "unscr1973")) :
      (f : False) : false
      (t) : true
