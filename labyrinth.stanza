defpackage labyrinth :
   import core
   import collections
   import cards
   import GameBoardGraphics
   import communicator

; stub
; todo: use mprint later
defn gprint<?T> (s : ?T ) :
   print(s)

defn gprintln<?T> (s : ?T ) :
   println(s)


defn doLog (log : True|False) -> False :
   println("doLog %_" % [log])

defstruct Country :
   name  : String
   attrs : HashTable<String,?>

defn remove (country : Country|False, key : String ) -> True|False :
   match(country) :
      (c : Country) : remove(attrs(c), key)
      (f) : false

defn set (country : Country, k : String, v : ?) -> False :
   set(attrs(country), k, v)

defmethod print (o : OutputStream, country : Country ) :
   print("%_ : [" % [name(country)])
   for attr in attrs(country) do :
      val k = key(attr)
      val v = value(attr)
      print("  %_: %_" % [k, v] )
   println("  ]")

defn to-country (name : String, xs : Tuple<KeyValue<String,?>>) -> Country :
   val h = HashTable<String,?>()
   for x in xs do :
      h[key(x)] = value(x)
   val country = Country(name, h)
   country

defstruct Countries :
   c : HashTable<String,Country>

defn to-countries ( kvs : Tuple<KeyValue<String,?>> ) -> Countries :
   val t = Countries(HashTable<String,?>())
   for kv in kvs do :
      val name = key(kv)
      val country = to-country(name, value(kv))
      t[name] = country
   t

defn get (countries : Countries, name : String) -> Country|False :
   c(countries)[name]

defn set (countries : Countries, name : String, country : Country) -> False :
   set(c(countries), name, country)

defmethod print (o : OutputStream, countries : Countries ) :
   val country-hash = c(countries)
   for country in country-hash do :
      print(o, value(country) )

val baseRoutes = [
   ["syria", "iraq"], ["iraq", "saudiarabia"], ["saudiarabia", "yemen"],
   ["saudiarabia", "gulfstates"], ["gulfstates", "iran"], ["afghanistan", "pakistan"],
   ["iraq", "gulfstates"], ["gulfstates", "pakistan"], ["afghanistan", "iran"],
   ["afghanistan", "centralasia"], ["centralasia", "iran"], ["iran", "turkey"], 
   ["iraq", "iran"], ["iran", "pakistan"],
   ["syria", "turkey"], ["syria", "lebanon"], ["syria", "jordan"],
   ["turkey", "serbia"], ["turkey", "schengen"], ["turkey", "russia"], ["turkey", "iraq"],
   ["caucasus", "iran"], ["caucasus", "turkey"], ["caucasus", "centralasia"],
   ["caucasus", "russia"], ["centralasia", "china"], ["centralasia", "russia"],
   ["russia", "serbia"], ["russia", "schengen"], ["lebanon", "schengen"], ["lebanon", "israel"],
   ["jordan", "israel"], ["jordan", "iraq"], ["jordan", "saudiarabia"],
   ["israel", "egypt"], ["yemen", "somalia"],
   ["egypt", "libya"], ["egypt", "sudan"],
   ["libya", "sudan"], ["libya", "schengen"], ["libya", "algeria"],
   ["somalia", "kenya"], ["somalia", "sudan"],
   ["sudan", "kenya"], ["algeria", "schengen"], ["algeria", "morocco"],
   ["morocco", "schengen"], ["serbia", "schengen"], ["uk", "canada"], 
   ["uk", "schengen"], ["uk", "us"], ["canada", "schengen"], ["canada", "us"],
   ["us", "schengen"], ["us", "philippines"], ["philippines", "thailand"], ["philippines", "indonesia"],
   ["indonesia", "thailand"], ["indonesia", "india"], ["indonesia", "pakistan"],
   ["indea", "pakistan"], ["thailand", "china"]
]

; Don't reorder this table. It is according to Random Schengen Table
val schengens = ["scandinavia", "benelux", "germany", "france", "spain", "italy", "easterneurope"]

; Shia-mix Country table (9.5)
val shiamixTable_tuple = [ 
   3 => "syria", 4 => "syria", 5 => "syria", 6 => "syria",
   7 => "iran", 8 => "saudiarabia", 9 => "turkey", 10 => "iraq",
   11 => "gulfstates", 12 => "yemen", 13 => "pakistan", 14 => "lebanon",
   15 => "afghanistan", 16 => "afghanistan", 17 => "afghanistan", 18 => "afghanistan"
]
val shiamixTable = HashTable<Int, String>()
for s in shiamixTable_tuple do :
   shiamixTable[key(s)] = value(s)

val usmarkers = [ "advisors", "unscr1973", "nato", "maerskalabama" ]
val jihadistmarkers = ["scsc", "qataricrisis", "trainingcamps", "bloodythursday", "3cupsoftea", "censorshop" ]

val board_tuple = [
   "us" => ["name" => "us", "govern" => "good"]
   "canada" => [ "name" => "canada" "govern" => "good" ]
   "uk" => [ "name" => "uk" "govern" => "good" "recruit" => 3 ]
   "spain" => [ "name" => "spain" "govern" => "good" "schengen" => true "recruit" => 2 ]
   "france" => [ "name" => "france" "govern" => "good" "schengen" => true "recruit" => 2 ]
   "italy" => [ "name" => "italy" "govern" => "good" "schengen" => true ]
   "benelux" => ["name" => "benelux", "govern" => "good", "schengen" => true],
   "germany" => ["name" => "germany", "govern" => "good", "schengen" => true],
   "scandinavia"=> ["name"=> "scandinavia", "govern"=> "good", "schengen" => true],
   "easterneurope"=> ["name" => "easterneurope", "govern" => "good", "schengen" => true],
   "serbia" => ["name" => "serbia", "govern" => "good"],
   "russia" => ["name"=> "russia", "govern" => "fair"],
   "caucasus" => ["name" => "caucasus", "govern" => "fair"],
   "iran" => ["name" => "iran", "govern" => "fair"],
   "israel" => ["name" => "israel", "govern" => "good", "posture" => "hard", "permposture" => true],
   "india" => ["name" => "india", "govern" => "good"],
   "china" => ["name" => "china", "govern" => "fair"],
   "thailand" => ["name" => "thailand", "govern" => "fair"],
   "philippines"=> ["name" => "philippinse", "govern" => "fair", "recruit" => 3],
   "kenya" => ["name" => "kenya", "govern" => "fair", "african" => true],

   ; Muslim countries
   "indonesia" => ["name" => "indonesia", "muslim" => true, "resource" => 3, "oil" => true, "sunni" => true],
   "pakistan" => ["name" => "pakistan", "muslim" => true, "resource" => 2, "arsenal" => 3],
   "afghanistan" => ["name" => "afghanistan", "muslim" => true, "resource" => 1],
   "centralasia" => ["name" => "centralasia", "muslim" => true, "resource" => 2, "sunni" => true],
   "gulfstates" => ["name" => "gulfstates", "muslim" => true, "resource" => 3, "oil" => true],
   "yemen" => ["name" => "yemen", "muslim" => true, "resource" => 1],
   "iraq" => ["name" => "iraq", "muslim" => true, "resource" => 3, "oil" => true],
   "saudiarabia" => ["name" => "saudiarabia", "muslim" => true, "resource" => 3, "oil" => true],
   "somalia" => ["name" => "somalia", "muslim" => true, "resource" => 1, "sunni" => true, "african" => true],
   "syria" => ["name" => "syria", "muslim" => true, "resource" => 2, "sunni" => true],
   
   "jordan" => ["name" => "jordan", "muslim" => true, "resource" => 1, "sunni" => true],
   "turkey" => ["name" => "turkey", "muslim" => true, "resource" => 2],
   "lebanon" => ["name" => "lebanon", "muslim" => true, "resource" => 1],
   "egypt" => ["name" => "egypt", "muslim" => true, "resource" => 3, "sunni" => true],
   "sudan" => ["name" => "sudan", "muslim" => true, "resource" => 1, "oil" => true, "sunni" => true, "african" => true],
   "libya" => ["name" => "libya", "muslim" => true, "resource" => 1, "oil" => true, "sunni" => true, "african" => true],
   "algeria" => ["name" => "algeria", "muslim" => true, "resource" => 2, "oil" => true, "sunni" => true, "african" => true],
   "morocco" => ["name" => "morocco", "muslim" => true, "resource" => 2, "sunni" => true, "african" => true]
]


val awakenBoard_tuple = [
   "mali" => ["name" => "mali" "muslim" => true "resource" => 1, "sunni" => true "african" => true ]
   "nigeria" => [ "name" => "algeria" "govern" => "poor" "african" => true ]
   "syria" => [ "name" => "syria" "muslim" => true "resource" => 2 "arsenal" => 2 ]
   "iran" => ["name" => "iran" "arsenal" => 1]
]
val awakenBoard : HashTable<String, Country> = HashTable<String, Country>()
for c in awakenBoard_tuple do :
   val k = key(c) as String
   val v = value(c)
   awakenBoard[k] = to-country(k, v)

val ISILHMBoard_tuple = [
   "nigeria" => [ "name" => "nigeria" "muslim" => true "resource" => 2 "sunni" => true "african" => true ]
]

val random_muslim_country = [
      ["morocco", "syria", "-"],
      ["algeria", "jordan", "indonesia"],
      ["libya", "turkey", "lebanon"],
      ["egypt", "saudiarabia", "iraq"],
      ["sudan", "gulfstates", "afghanistan"],
      ["somalia", "yemen", "pakistan"]
   ]
val random_muslim_country2 = ["centralasia", "centralasia", "iraq", "mali", "nigeria", "nigeria"]

val personalities = [110, 111, 112, 115, 116, 215, 216, 219, 225, 237, 328, 329, 338, 342, 352]

val ISILHMSetup_tuple = [
   "syria" => [
      "name" => "syria",
      "align" => "neutral",
      "govern" => "fair",
      "caliphate" => "capital",
      "civilwar" => true,
      "militia" => 3,
      "activecell" => 5
   ],
   "iraq" => [
      "name" => "iraq",
      "align" => "neutral",
      "govern" => "poor",
      "caliphate" => "country",
      "civilwar" => true,
      "militia" => 3,
      "activecell" => 4
   ],
   "yemen" => [
      "name" => "yemen",
      "align" => "neutral",
      "govern" => "poor",
      "civilwar" => true,
      "militia" => 2,
      "sleepercell" => 2
   ],
   "gulfstates"=> [
      "name" => "gulfstates",
      "align" => "ally",
      "govern" => "fair",
      "troop" => 2
   ],
   "afghanistan" => [
      "name" => "afghanistan",
      "align" => "ally",
      "govern" => "poor",
      "troop" => 2,
      "sleepercell" => 1
   ],
   "nigeria"=> [
      "name" => "nigeria",
      "muslim" => true,
      "sunni" => true,
      "align" => "neutral",
      "govern" => "poor",
      "resource" => 2,
      "sleepercell" => 1,
      "african" => true
   ],
   "uk" => [
      "name" => "uk",
      "posture" => "hard"
   ]
]

val awakenRoutes = [
   ["mali", "morocco"], ["mali", "algeria"], ["mali", "nigeria"], ["nigeria", "sudan"], ["nigeria", "kenya"]
]

val surge-decks = [ 
   [
      1, 10, 12, 13, 15, 16, 18, 19, 20, 21, 22, 24, 25, 28, 29, 
      30, 32, 33, 35, 36, 40, 42, 45, 46, 49, 50, 52, 53, 60, 63, 
      68, 70, 72, 73, 74, 77, 78, 79, 81, 82, 83, 89, 90, 91, 93, 
      95, 97, 100, 101, 103, 105, 106, 107, 108, 111, 112, 113, 118, 119, 120
   ], [
      123, 124, 127, 128, 130, 131, 134, 135, 136, 139, 140, 141, 143, 146, 148,
      153, 154, 160, 161, 162, 163, 164, 168, 170, 172, 175, 176, 177, 179, 185,
      186, 190, 191, 195, 196, 197, 198, 199, 200, 202, 203, 205, 206, 207, 208,
      210, 211, 212, 213, 214, 219, 220, 221, 223, 227, 228, 229, 230, 237, 239
   ] 
]

public defstruct Labyrinth :
   awakening : True|False with : (setter => set-awakening)
   foreverwar : True|False with : (setter => set-foreverwar)
   scenario : String
   usplayer : String with : (setter => set-usplayer)
   jihadistplayer : String with : (setter => set-jihadistplayer)
   board : Countries with : (setter => set-board)
   countries : Countries with : (setter => set-countries)
   routes : Vector<[String,String]> with : (setter => set-routes)
   deck : Vector<Int>
   abort : True|False with : (setter => set-abort)
   reshuffled : True|False with : (setter => set-reshuffled)
   currentplayer : String with : (setter => set-currentplayer)
   currentphase : Int with : (setter => set-currentphase)
   firstPlot : True|False with : (setter => set-firstPlot)
   firstPlotCard : Int with : (setter => set-firstPlotCard)
   heldCard : True|False with : (setter => set-heldCard)
   lapsing : Vector<Int>
   plots : Vector<Int|String>
   usedPlots : Vector<Int|String>
   spentUnits : Vector<String>
   cellcamps : Int with : (setter => set-cellcamps)
   maxcamps : Int with : (setter => set-maxcamps)
   lesscell : Int with : (setter => set-lesscell)
   plotSuccess : True|False with : (setter => set-plotSuccess)
   plotAvailables : Vector<String|Int> 
   nbDeck : Int with : (setter => set-nbDeck)
   turn : Int with : (setter => set-turn)
   trooptrack : Int with : (setter => set-trooptrack)
   offmap : Int with : (setter => set-offmap)
   funding : Int with : (setter => set-funding)
   celltrack : Int with : (setter => set-celltrack)
   prestige : Int with : (setter => set-prestige)
   markers : Vector<String>
   loadedDeck :  Vector<Int>
   winMethod : String with : (setter => set-winMethod)
   currentphaseCountries : Vector<String>
   lastphaseCountries : Vector<String>
   discard : Vector<Int>
   removed : Vector<Int>
   ushand : Vector<Int>
   jihadisthand : Vector<Int>
   eventNotUsed : Vector<Int>
   eventUsed : Vector<Int>
   eventAsEvent : Vector<Int>
   usreserve : Int with : (setter => set-usreserve)
   jihadistreserve : Int with : (setter => set-jihadistreserve)
   gameend : True|False with : (setter => set-gameend)
   reason : String with : (setter => set-reason)
   currentcard : Int with : (setter => set-currentcard)
   gameBoard : GameBoardGraphics|False with : (setter => set-gameBoard)
   comm : Communicator|False with : (setter => set-comm)
   decks : Tuple<Tuple<Int>>|False with : (setter => set-decks)
   finalWin : True|False with : (setter => set-finalWin)
   winner : String with : (setter => set-winner)

defmethod print (o : OutputStream, lab : Labyrinth) :
   println(o, decks(lab))
   println(o, deck(lab))
   println(o, countries(lab))
   println(o, routes(lab))
   println(o, scenario(lab))

defn doLog (lab : Labyrinth, log : Int) -> False :
   if log >= 1 :
      doLog(true)
   else :
      doLog(false)


public defn make-labyrinth (  awakening : True|False, foreverwar : True|False, scenario : String, 
                              usplayer : String, jihadistplayer : String, 
                              terminal: True|False, log: Int ) -> Labyrinth :
   val lab = Labyrinth( awakening, 
                        foreverwar,
                        scenario,
                        usplayer,
                        jihadistplayer,
                        to-countries(board_tuple), 
                        Countries(HashTable<String,?>()),
                        Vector<[String,String]>(),
                        Vector<Int>(),    ; deck 
                        false,
                        false,      ; reshuffled
                        "jihadist"
                        0
                        false
                        0
                        false
                        Vector<Int>()
                        Vector<Int|String>()
                        Vector<Int|String>()
                        Vector<String>()
                        0
                        0
                        0
                        false
                        to-vector<Int>([1, 1, 1, 2, 2, 3])
                        3
                        1
                        15
                        0
                        7
                        15
                        6
                        Vector<String>()
                        Vector<Int>()        ; loadedDeck
                        ""
                        Vector<String>()
                        Vector<String>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        Vector<Int>()
                        0
                        0
                        false
                        ""
                        0
                        false          ; gameBoardGraphics
                        false          ; communicator
                        false          ; decks
                        false          ; finalWin
                        ""             ; winner
                     )
   doLog(lab, log)   
   set-gameBoard(lab, make-GameBoardGraphics(lab))
   set-comm(lab, make-communicator(lab, usplayer, jihadistplayer, terminal, log))
   reset(lab)
   lab


; to-do : complete reset
defn reset (lab : Labyrinth) :
   println("Reset Game")
   if scenario(lab) == "Surge":
      set-awakening(lab, false)
   set-countries(lab, board(lab))
   set-routes(lab, to-vector<[String,String]>(baseRoutes))
   if awakening(lab) :
      for c in awakenBoard_tuple do :
         val cs = countries(lab) 
         val k = key(c) as String
         val v = value(c)
         cs[k] = to-country(k, v)
      val cs = countries(lab)
      val syria = cs["syria"]
      match(syria) : ( (syria : Country) : remove(syria, "sunni") )
      for route in awakenRoutes do :
         val result = find( fn ( x : [String,String], y : [String,String] ) -> True|False : (
                              if ( x[0] == y[0] and x[1] == y[1] ) or ( x[0] == y[1] and x[1] == y[0] ) :
                                 true
                              else :
                                 false )
                              routes(lab)
                              [route] )
         match(result) : ((result:False) : add(routes(lab), route) )
   if scenario(lab) == "ISILHM":
      val cs = countries(lab)
      for c in ISILHMBoard_tuple do :
         cs[key(c)] = to-country(key(c), value(c))
      for kv in ISILHMSetup_tuple do :
         val name = key(kv)
         val attrs = value(kv)
         for attr in attrs do:
            match( cs[name] ) :
               (c : Country) : set(c, key(attr), value(attr))
      remove(cs["iran"], "arsenal")
      remove(cs["syria"], "arsenal")
         
   ; gprint("scenario=%_" % [scenario(lab)])
   ; loadedDeck is for testing only
   clear(loadedDeck(lab))
   ; add(loadedDeck(lab), [195])
   clear(currentphaseCountries(lab))
   clear(lastphaseCountries(lab))
   clear(discard(lab))
   clear(removed(lab))
   clear(ushand(lab))
   clear(jihadisthand(lab))
   clear(eventNotUsed(lab))
   add-all(eventNotUsed(lab), deck(lab))
   clear(eventNotUsed(lab))
   clear(eventUsed(lab))
   clear(eventAsEvent(lab))
   set-usreserve(lab, 0)
   set-jihadistreserve(lab, 0)
   set-gameend(lab, false)
   set-reason(lab, "")
   clear(lapsing(lab))
   clear(plots(lab))
   clear(usedPlots(lab))
   clear(spentUnits(lab))
   set-cellcamps(lab, 0)
   set-maxcamps(lab, 0)
   set-lesscell(lab, 0)
   set-plotSuccess(lab, false)
   clear(plotAvailables(lab))
   add-all(plotAvailables(lab), to-vector<Int>([1, 1, 1, 2, 2, 3]))
   set-nbDeck(lab, 3)
   set-turn(lab, 1)
   clear(markers(lab))
   set-offmap(lab, 0)

   if scenario(lab) == "Surge":
      set-awakening(lab, false)
      set-foreverwar(lab, false)
      set-nbDeck(lab, 1)
      set-prestige(lab, 4)
      setPosture(lab, "us", "hard")
      set-trooptrack(lab, 5)
      set-funding(lab, 6)
      set-celltrack(lab, 15)
      setGovern(lab, "libya", "poor")
      setAlign(lab, "libya", "adversary")
      setGovern(lab, "syria", "fair")
      setAlign(lab, "syria", "adversary")
      addOneCell(lab, "syria", "recruit", true)
      setGovern(lab, "iraq", "poor")
      setAlign(lab, "iraq", "ally")
      setTroop(lab, "iraq", 5)
      addOneCell(lab, "iraq", "recruit", true)
      addOneCell(lab, "iraq", "recruit", true)
      addOneCell(lab, "iraq", "recruit", true)
      setRegimeChange(lab, "iraq", "tan")
      setMarker(lab, "iraq", "sadr", true)
      setMarker(lab, "iraq", "alanbar", true)
      addOneCell(lab, "iran", "recruit", true)
      setGovern(lab, "saudiarabia", "poor")
      setAlign(lab, "saudiarabia", "ally")
      addOneCell(lab, "saudiarabia", "recruit", true)
      setGovern(lab, "gulfstates", "fair")
      setAlign(lab, "gulfstates", "ally")
      setTroop(lab, "gulfstates", 2)
      setGovern(lab, "pakistan", "fair")
      setAlign(lab, "pakistan", "ally")
      addOneCell(lab, "pakistan", "recruit", true)
      setMarker(lab, "pakistan", "fata", true)
      setGovern(lab, "afghanistan", "poor")
      setAlign(lab, "afghanistan", "ally")
      setTroop(lab, "afghanistan", 3)
      for i in 0 to 2 do :
         addOneCell(lab, "afghanistan", "recruit", true)
      addOneAid(lab, "afghanistan", false)
      setRegimeChange(lab, "afghanistan", "tan")
      setMarker(lab, "afghanistan", "nato", 1)
      setGovern(lab, "somalia", "poor")
      setAlign(lab, "somalia", "neutral")
      addOneCell(lab, "somalia", "recruit", true)
      setBesiegedRegime(lab, "somalia")
      setGovern(lab, "indonesia", "fair")
      setAlign(lab, "indonesia", "neutral")
      addOneCell(lab, "indonesia", "recruit", true)
      setPosture(lab, "uk", "hard")
      setPosture(lab, "scandinavia", "soft")
      set-decks(lab, surge-decks) 
   clear(currentphaseCountries(lab))
   clear(lastphaseCountries(lab))
   gprint(countries(lab))
   gprint(routes(lab))
   gprint(decks(lab))
   report(lab)
   set-currentplayer(lab, "jihadist")
   set-currentphase(lab, 0)
   set-turn(lab, 0)  
   println("End Reset Game")

defn stopOneGame (lab : Labyrinth) :
   set-abort(lab, true)

public defn playOneGame (lab : Labyrinth, usplayer : String|False, jihadistplayer : String|False) :
   match(usplayer):
      (u : String) : set-usplayer(lab, u)
      (u) : u
   match(jihadistplayer):
      (j : String) : set-jihadistplayer(lab, j)
      (j) : j
   clear(eventNotUsed(lab))
   add-all(eventNotUsed(lab), deck(lab))
   shuffleDeck(lab)
   gprintln("Shuffled Deck=%_" % [deck] )
   dealHands(lab)
   set-finalWin(lab, false)
   ; todo: try except is used in "web" ui
   ;try:
   label<False> break :
      while true :
         set-turn(lab, turn(lab)+1)
         gprintln("Turn %_" % [ turn(lab) ])
         if checkAutoWin(lab) :
            break
         if playOneTurn(lab):
            break
   ;except WebAbort:
   ;   return False, '', '', self.turn, ''
   ; determine winner
   set-reason(lab, "Auto Win")
   if finalWin(lab) == true:
      set-reason(lab, "Final Score")
   gprint(countries(lab))
   report(lab)
   endOneGame(comm(lab) as Communicator)
   [true, winner(lab), reason(lab), turn(lab), winMethod(lab)]

defn playOneTurn (lab : Labyrinth) :
   gprintln("playOneTurn")
   ; play one turn
   set-reshuffled(lab, false)
   set-currentplayer(lab, "jihadist")
   ; set-currentplayer(lab, "us")   ; testing only
   set-currentphase(lab, 0)
   set-firstPlot(lab, false)
   set-firstPlotCard(lab, 0)
   set-heldCard(lab, false)
   label<True|False> return :
      while not ((length(ushand(lab)) == 0 and length(jihadisthand(lab)) == 0)
                  or (heldCard(lab) and length(ushand(lab)) == 1 and length(jihadisthand(lab)) == 0)):
         playOneCard(lab)
         checkTrainingCamps(lab)
         if gameend(lab):
               return(true)
      endTurn(lab)

defn playOneCard (lab : Labyrinth) -> False:
   false

defn endTurn (lab : Labyrinth) -> True|False :
   gprintln("End Turn")
   if not isPirates(lab):
      gprintln("Jihadist Funding -1")
      changeFunding(lab, (- 1))
   if countIRCountries(lab) > 0:
      gprintln("IR Country")
      changePrestige(lab, (- 1))
   if (getGWOTHard(lab) >= 3 and getPosture(lab, "us") == "hard") or (
         getGWOTHard(lab) <= (- 3) and getPosture(lab, "us") == "soft"):
      gprintln("US Posture same as World S3/H3")
      changePrestige(lab, 1)
   if usplayer(lab) != "bot":
      set-usreserve(lab, 0)
   if jihadistplayer(lab) != "bot":
      set-jihadistreserve(lab, 0)
   add-all(plotAvailables(lab), usedPlots(lab))
   clear(usedPlots(lab))
   polarization(lab)
   attrition(lab)
   label<True|False> return :
      if checkAutoWin(lab):
         return(true)
      if dealHands(lab):
         set-reshuffled(lab, true)
      if reshuffled(lab):
         set-nbDeck(lab, nbDeck(lab) - 1)
         if nbDeck(lab) == 0:
            set-gameend(lab, true)
            determineFinalWinner(lab)
            return(true)
      if isMarker(lab, "china", "scsc"):
         if getPosture(lab, "us") == getPosture(lab, "china"):
               set-trooptrack(lab, trooptrack(lab) + 2)
               set-offmap(lab, offmap(lab) - 2)
               removeMarker(lab, "china", "scsc", true)
               gprintln("2 Troops from South China Sea Crisis return")
      if contains?(lapsing(lab), 179):
         set-trooptrack(lab, trooptrack(lab) + 2)
         set-offmap(lab, offmap(lab) - 2)
         gprintln("2 Troops from Korean Crisis return")
      if contains?(lapsing(lab), 239):
         for country in c(countries(lab)) do:
            setAttr(lab, key(country), "truce", false)
      clear(lapsing(lab))
      flipRegimeChange(lab)
      gprint(countries(lab))
      report(lab)
      false



defn report (lab : Labyrinth) :
   gprint( "GR=%_ IR=%_ FGC=%_ PIC=%_ P=%_ F=%_",
      % [ getGoodResource(lab) getIslamResource(lab) getFGC(lab) getPIC(lab) prestige(lab) funding(lab)]
   )
   gprint(
      "T=%_ C=%_ US=%_ World="
      % [ getTroopLevel(lab) getCellOnMap(lab) getPosture(lab, "us")]
   )
   var gwot = getGWOTHard(lab)
   var worldStr : String = ""
   if gwot > 0:
      worldStr = "Hard "
   else if gwot < 0:
      worldStr = "Soft "
   else:
      worldStr = ""
   worldStr = append(worldStr, to-string(abs(gwot)))
   gprintln("%_" % [worldStr])
   gprintln( "Awakening=%_ Reaction=%_ TroopsOnTrack=%_ Off-map=%_ CellsOnTrack=%_"
      % [countAwaken(lab) countReact(lab) trooptrack(lab) offmap(lab) celltrack(lab)]
   )
   gprintln("CellsInCamps=%_ CampsCapacity=%_ LessCells=%_"
      % [cellcamps(lab) maxcamps(lab) lesscell(lab)]
   )
   gprintln("CurrentPlots=%_ AvailablePlots=%_ UsedPlots=%_"
      % [plots(lab) plotAvailables(lab) usedPlots(lab)]
   )
   gprintln("USReserve=%_ JihadistReserve=%_" % [usreserve(lab) jihadistreserve(lab)] )
   gprintln("Lapsing=%_" % [ lapsing(lab) ])
   gprintln("Deck=%_" % [ deck(lab) ])
   gprintln("Discard=%_" % [ discard(lab) ])
   gprintln("Removed=%_" % [ removed(lab) ])

   qsort!(eventUsed(lab))
   gprintln("Events used=%_" % [ eventUsed(lab) ] )
   gprintln("CurrentPhaseCountries=%_" % [ currentphaseCountries(lab) ] )
   gprintln("LastPhaseCountries=%_" % [ lastphaseCountries(lab) ] )


defn determineFinalWinner (lab : Labyrinth) :
   gprintln("Determine Final Winner")
   var ir = getIslamResource(lab)
   var gr = getGoodResource(lab)
   var green = 0
   for country in c(countries(lab)) do:
      val name = key(country)
      if isGreenRegimeChange(lab, name):
            green  = green + getResource(lab, name)
   if scenario(lab) == "ISILHM":
      var cc = false
      let :
         label<False> break:
            for country in c(countries(lab)) do:
               val name = key(country)
               if isCaliphateCapital(lab, name):
                  ir = ir + 1
                  cc = true
                  break
      if not cc:
         gr = gr + 2
   else if scenario(lab) == "Surge":
      val v = extract(
               lab, 
               fn (x:String) : getGovern(lab, x) == "islamrule" or isRegimeChange(lab, x),
               ["afghanistan" "iraq"]
            )
      if length(v) > 0:
         gprintln("Bonus +1 IR in %_ for %_ in Islamist Rule or Regime Change" % [scenario(lab) v])
         ir = ir + 1
   gprintln("Good Resource=%_" % [gr])
   gprintln("Islamic Resource=%_" % [ir])
   gprintln("Green Regime Change Resource=%_" % [green])
   if gr > (ir + green) * 2:
      set-winner(lab, "us")
      set-winMethod(lab, "GR > 2x (IR + Green RC)")
   else:
      set-winner(lab, "jihadist")
      set-winMethod(lab, "GR <= 2x (IR + Green RC)")
   gprintln("Winner is: %_" % [winner(lab)])
   set-finalWin(lab, true)

defn setAttr (lab: Labyrinth, name: String, attr: String, value: String|Int|True|False) -> True|False :
   val country = countries(lab)[name]
   match(country) :
      (country : Country) : 
         val attrs = attrs(country)
         match(value):
            (f:False) : remove(attrs, attr)
            (v:Int) :
               if v == 0:
                  remove(attrs, attr)
               else :
                  attrs[attr] = value
            (value) : attrs[attr] = value
         addCountryToCurrentPhase(lab, name)
         gprint(country)
         true
      (country) : false

defn getAttr (lab: Labyrinth, name : String, attr: String) -> String|Int|True|False :
   val cc = c(countries(lab))
   ; gprintln("GetAttr: %_ %_" % [name attr])
   val country = cc[name]
   match(country):
      (country : Country) :
         val value = get?(attrs(country), attr)
         match(value):
            (value : False): false
            (value) : value
      (f) : false

defn setPosture (lab : Labyrinth, name: String, posture : String) :
   if setAttr(lab, name, "posture", posture) :
      gprintln("%_ is %_. World=%_" % [name, getPosture(lab, name), getGWOTHard(lab)])
         
defn setGovern (lab : Labyrinth, name: String, govern : String) :
   setAttr(lab, name, "govern", govern)

defn setAlign (lab : Labyrinth, name: String, align : String) :
   setAttr(lab, name, "align", align)
   if align == "adversary":
      removeAllAdvisors(lab, name)

defn addOneCell (lab: Labyrinth, name : String, reason : String, event: True|False ) :
   ; check Cell Track
   var result = ""
   label<False> break :
      if reason == "recruit":
         if cellAvailable(lab, event) <= 0 :
            break
      if isCaliphate(lab, name):
         val cell = getActiveCell(lab, name, false) + 1
         setActiveCell(lab, name, cell)
         gprintln("one active cell is added in %_ to %_" % [name cell])
         result = "activecell"
      else:
         val cell = getSleeperCell(lab, name, false) + 1
         setSleeperCell(lab, name, cell)
         gprintln("one sleeper cell is added in %_ to %_" % [name cell])
         result = "sleepercell"
      if reason != "travelto":
         removeCadre(lab, name)
      if reason == "recruit":
         if celltrack(lab) > 0:
            val cell = celltrack(lab) - 1
            set-celltrack(lab, cell)
         else:
            val cell = cellcamps(lab) - 1
            set-cellcamps(lab, cell)
      gprint(countries(lab)[name])
      testCountry(lab, name)
      addCountryToCurrentPhase(lab, name)
   result

defn setTroop (lab : Labyrinth, name : String, troop : Int) :
   label<False> break :
      if name == "track" :
         set-trooptrack(lab, troop)
         break

      val country = countries(lab)[name]
      match(country):
         (country : Country) :
            if troop == 0:
               remove(attrs(country), "troop")
            else:
               setAttr(lab, name, "troop", troop)
               removeAllAdvisors(lab, name)
            addCountryToCurrentPhase(lab, name)

defn setRegimeChange (lab : Labyrinth, name : String, color : String) :
   if setAttr(lab, name, "regimechange", color) :
      if color == "green" :
         connectCaliphate(lab, name)
      
defn setMarker (lab : Labyrinth, name : String, marker : String, value : String|True|Int) :
   if name == "markers" :
      add(markers(lab), marker)
   else :
      setAttr(lab, name, marker, value)

defn addOneAid (lab : Labyrinth, name : String, event: True|False) :
   label<False> break :
      var aid = getAid(lab, name)
      if aid >= 1 and event == false:
         break
      aid = aid + 1
      setAttr(lab, name, "aid", aid)
      gprint("Aid=%_ in %_" % [aid name])

defn setBesiegedRegime (lab : Labyrinth, name : String) :
   setAttr(lab, name, "besiegedregime", true)

defn addCountryToCurrentPhase (lab : Labyrinth, name : String) :
   val cpc = currentphaseCountries(lab)
   val f = find(fn (x : String) : x == name, cpc)
   if f is False :
      add(cpc, name)

defn getPosture (lab : Labyrinth, name : String):
   val posture = getAttr(lab, name, "posture")
   match(posture) :
      (posture : String) : posture
      (f) : "untested"

defn getGWOTHard (lab : Labyrinth) :
   ; count hard as 1 and soft as -1
   var gwot = 0
   for country in c(countries(lab)) do:
      val name = key(country)
      if not (name == "us" or isMuslim(lab, name) or name == "iran"):
         val posture = getPosture(lab, name)
         if posture == "hard":
               gwot = gwot + 1
         else if posture == "soft":
               gwot = gwot - 1
   if gwot > 3:
      gwot = 3
   if gwot < (- 3):
      gwot = (- 3)
   gwot

defn removeAllAdvisors (lab : Labyrinth, name : String) :
   if setAttr(lab, name, "advisors", false) :
      gprintln("Remove All Advisors in %_" % [name])

defn cellAvailable (lab : Labyrinth, event: True|False) :
   var result = 0
   label<False> break:
      if event:
         result = celltrack(lab) + cellcamps(lab)
         break
      var buildable = 0
      if funding(lab) <= 3:
         buildable = celltrack(lab) - 10
      else if funding(lab) <= 6:
         buildable = celltrack(lab) - 5
      else if funding(lab) <= 8:
         buildable = celltrack(lab)
      else if funding(lab) == 9:
         buildable = celltrack(lab) + cellcamps(lab)
      result = buildable
   result

defn isCaliphate (lab : Labyrinth, name : String) -> True|False:
   val ic = getAttr(lab, name, "caliphate")
   match(ic):
      (ic:True) : ic
      (ic) : false
   
defn getActiveCell (lab : Labyrinth, name : String, withMarkers: True|False) -> Int :
   var cell = 0
   val ac = getAttr(lab, name, "activecell")
   match(ac):
      (ac : Int) : cell = cell + ac
      (ac) : cell = cell
   if withMarkers:
      match( getAttr(lab, name, "sadr") ):
         (t : True) : cell = cell + 1
         (t) : cell = cell
   cell

defn setActiveCell (lab : Labyrinth, name : String, cell : Int) :
   setAttr(lab, name, "activecell", cell)
   
defn getSleeperCell (lab : Labyrinth, name : String, withMarkers : True|False) -> Int:
   val sc = getAttr(lab, name, "sleepercell")
   match(sc):
      (sc:Int) : sc
      (f) : 0

defn getCell (lab : Labyrinth, name : String, includeMarkers : True|False) :
   getSleeperCell(lab, name, includeMarkers) + getActiveCell(lab, name, includeMarkers)
      
defn setSleeperCell (lab : Labyrinth, name : String, cell : Int) :
   setAttr(lab, name, "sleepercell", cell)

defn removeCadre (lab : Labyrinth, name : String) :
   if setAttr(lab, name, "cadre", false) :
      gprintln("Cadre removed in %_" % [name])

defn isCadre (lab : Labyrinth, name : String) -> True|False :
   val cadre = getAttr(lab, name, "cadre")
   match(cadre):
      (c : True) : true
      (c) : false

defn testCountry (lab : Labyrinth, name : String) -> False :
   label<False> break:
      if not isUntested(lab, name):
         break
      if isMuslim(lab, name):
         rollGovern(lab, name)
         setAlign(lab, name, "neutral")
         gprint("%_ is a %_ %_" % [name getAlign(lab,name) getGovern(lab,name)])
      else:
         if name == "iran":
               break
         rollPosture(lab, name, 0)

defn getAlign (lab : Labyrinth, name : String) -> String :
   val a = getAttr(lab, name, "align")
   match(a):
      (a : String) : a
      (a) : "untested"

defn getGovern (lab : Labyrinth, name : String) -> String|False :
   val g = getAttr(lab, name, "govern")
   match(g):
      (g: String) : g
      (g) : false

defn isMuslim (lab : Labyrinth, name : String) -> True|False :
   val im = getAttr(lab, name, "muslim")
   match(im) :
      (im:True) : true
      (im) : false
      
defn isUntested (lab : Labyrinth, name : String) -> True|False:
   if isMuslim(lab, name):
      if getGovern(lab, name) == "":
            true
      else:
            false
   else:
      if getPosture(lab, name) == "untested":
            true
      else:
            false

defn getAid (lab : Labyrinth, name : String) :
   val a = getAttr(lab, name, "aid")
   match(a):
      (a : Int) : a
      (a) : 0

defn rollGovern (lab : Labyrinth, name : String) :
   val die = rollOnce(lab)
   if die <= 4:
      setGovern(lab, name, "poor")
   else:
      setGovern(lab, name, "fair")
   gprintln("Country %_ is %_" % [name getGovern(lab,name)])

defn rollPosture (lab : Labyrinth, name : String, drm:Int) :
   gprint("Roll Posture for %_" % [name])
   var die = rollOnce(lab) + drm
   if name == "us":
      die = die + 1
   if die <= 4:
      gprint("soft")
      setPosture(lab, name, "soft")
   else:
      gprint("hard")
      setPosture(lab, name, "hard")

defn rollOnce (lab : Labyrinth) :
   val dice = rand(6) + 1
   gprintln("Rolled: %_" % [dice])
   dice

defn connectCaliphate (lab : Labyrinth, name : String) :
   var region = adjacentRegion(lab, [name])
   region = extract(lab, fn (x : String) : isCaliphate(lab, x), region)
   if length(region) > 0:
      setCaliphateCountry(lab, name)

defn adjacentRegion (lab : Labyrinth, origins : Tuple<String>) -> Tuple<String> :
   val adjs = to-vector<String>(origins)
   for country in c(countries(lab)) do :
      val name = key(country)
      if not contains?(origins, name):
         label<False> break:
            for c in origins do:
               if isAdjacent(lab, name, c, false):
                  add(adjs, name)
                  break
   to-tuple(adjs)

defn isAdjacent (lab : Labyrinth, fromname : String, toname : String, travel : True|False) :
   label<True|False> return:
      if fromname == toname:
         return(true)
      if contains?(schengens, fromname) and contains?(schengens, toname) and not (contains?(lapsing(lab), 169) and travel):
         return(true)
      if isMarker(lab, "gulfstates", "qataricrisis"):
         val gang = ["iran", "gulfstates", "saudiarabia", "yemen"]
         if contains?(gang, fromname) and contains?(gang, toname) :
               return(true)

      for route in routes(lab) do:
         val src = route[0]
         val dst = route[1]
         if src == fromname and dst == toname:
               return(true)
         else if src == toname and dst == fromname:
               return(true)

         ; one in schengens
         if contains?(schengens, fromname):
               if src == toname and dst == "schengen" and not (contains?(lapsing(lab), 169) and travel):
                  return(true)
               if dst == toname and src == "schengen":
                  return(true)
         if contains?(schengens, toname):
               if src == fromname and dst == "schengen" and not (contains?(lapsing(lab), 169) and travel):
                  return(true)
               if dst == fromname and src == "schengen":
                  return(true)
      return(false)

defn isMarker (lab : Labyrinth, name : String, marker : String) :
   if name == "markers":
      contains?(markers(lab), marker)
   else:
      val result = getAttr(lab, name, marker)
      match(result):
         (result:False) : false
         (result) : true

defn removeMarker (lab : Labyrinth, name : String, marker : String, value : True|Int):
   match(value):
      (value:True) :
         if name == "markers":
            remove-item(markers(lab), marker)
         else:
            setAttr(lab, name, marker, false)
      (value:Int) :
         var a = getMarker(lab, name, marker)
         match(a) :
            (a : Int) :
               var b = a
               b = b - 1
               if b == 0:
                  if name == "markers":
                     remove-item(markers(lab), marker)
                  else:
                     setAttr(lab, name, marker, false)
               else:
                     setMarker(lab, name, marker, b)

defn getMarker (lab : Labyrinth, name : String, marker : String) -> True|False|Int :
   if name == "markers":
      contains?(markers(lab), marker)
   else :
      val attr = getAttr(lab, name, marker)
      match(attr):
         (attr:True|False|Int) : attr
         (attr) : false

defn setCaliphateCountry (lab : Labyrinth, name : String) :
   setAttr(lab, name, "caliphate", "country")
   gprint("%_ becomes Caliphate Country" % [name])

defn setCaliphateCapital (lab : Labyrinth, name : String) :
   setAttr(lab, name, "caliphate", "capital")
   gprint("%_ becomes Caliphate Capital" % [name])

defn isCaliphateCapital (lab : Labyrinth, name : String) :
   val value = getAttr(lab, name, "caliphate")
   match(value) :
      (value : String) : if value == "capital" : true
      (value) : false
      
defn extract (lab : Labyrinth, func : String -> True|False, candidates : Tuple<String>|False):
   val v = Vector<String>()
   match(candidates) :
      (candidates:Tuple<String>) :
         for name in candidates do :
            if func(name):
               if not (name is String and isMarker(lab, name, "truce") and not mayEndTruce(lab, name)):
                  add(v, name)
      (candidates):
         for country in c(countries(lab)) do:
            val name = key(country)
            if func(name):
               if isMarker(lab, name, "truce"):
                  if mayEndTruce(lab, name):
                     add(v, name)
   to-tuple(v)

defn mayEndTruce (lab : Labyrinth, name : String) -> True|False :
   label<True|False> return:
      if not isMarker(lab, name, "truce"):
         return(true)
      val resources = getResource(lab, name)

      if currentplayer(lab) == "us" and prestige(lab) > resources or currentplayer(lab) == "jihadist" and funding(lab) > resources:
         val comm = comm(lab)
         match(comm):
            (comm:Communicator) :
               val ans = queryGeneric(comm, currentplayer(lab), to-string("End Truce in %_?"%[name]), ["y", "n"], "endtruce",
                                             [to-string("Yes, end Truce in %_" % [name]), "No"], false, false )
               if ans == "y":
                  if currentplayer(lab) == "us":
                     changePrestige(lab, (- resources))
                  else:
                     changeFunding(lab, (- resources))
                  removeMarker(lab, name, "truce", true)
                  remove(lapsing(lab), 239)
                  return(true)
      else:
         return(false)

defn getResource (lab : Labyrinth, name : String) -> Int :
   val country = c(countries(lab))[name]
   match(country):
      (country: Country) :
         val attrs = attrs(country)
         var resources = attrs["resource"]
         match(resources) :
            (r : Int) :
               if isCaliphateCapital(lab, name):
                     resources = resources + 1
               if contains?(lapsing(lab), 356) and isOil(lab, name):
                     resources = resources - 1
               if contains?(lapsing(lab), 117) and isOil(lab, name):
                     resources = resources + 1
               if contains?(lapsing(lab), 118) and isOil(lab, name):
                     resources = resources + 1
               if contains?(lapsing(lab), 236) and isOil(lab, name):
                     resources = resources + 1
               if contains?(lapsing(lab), 289):
                     val gang = ["iran", "iraq", "gulfstates", "saudiarabia"]
                     if contains?(gang, name):
                        resources = resources - 1
                     else if isOil(lab, name):
                        resources = resources + 1
               if resources < 0: resources = 0
               resources
            (resources) : 0
      (f) : 0

defn isOil (lab : Labyrinth, name : String) -> True|False :
   val oil = getAttr(lab, name, "oil")
   match(oil):
      (oil:False) : false
      (oil) : true

defn changeFunding (lab : Labyrinth, inc : Int) :
   val oFunding = funding(lab)
   set-funding(lab, funding(lab) + inc)
   if funding(lab) > 9 :
      set-funding(lab, 9)
   if funding(lab) < 1 :
      set-funding(lab, 1)
   gprint("Change Funding from %_ by %_ to %_" % [oFunding, inc, funding(lab)])

defn changePrestige (lab : Labyrinth, inc : Int) :
   val oPrestige = prestige(lab)
   set-prestige(lab, prestige(lab) + inc)
   if prestige(lab) > 12 :
      set-prestige(lab, 12)
   if prestige(lab) < 1 :
      set-prestige(lab, 1)
   gprint("Change Prestige from %_ by %_ to %_" % [oPrestige inc prestige(lab)])


defn getGoodResource (lab : Labyrinth):
   var resources = 0
   val validCountries = extract(lab, fn (x : String) : isMuslim(lab, x) and getGovern(lab, x) == "good", false)
   for name in validCountries do:
      resources = resources + getResource(lab, name)
   resources

defn getIslamResource (lab : Labyrinth) :
   var resources = 0
   val validCountries = extract( lab,
      fn (x : String) : isMuslim(lab, x) and (getGovern(lab, x) == "islamrule" or isCaliphateCapital(lab, x)), 
      false)
   for name in validCountries do:
      if getGovern(lab, name) == "islamrule":
            resources = resources + getResource(lab, name)
      else:
            resources = resources + 1
   resources

defn getFGC (lab : Labyrinth) -> Int:
   var count : Int = 0
   for country in c(countries(lab)) do:
      val name = key(country)
      val muslim = getAttr(lab, name, "muslim")
      if muslim is True:
         val govern = getAttr(lab, name, "govern")
         if govern is String :
            if govern == "good" or govern == "fair":
               count = count + 1
      
   count

defn getPIC (lab : Labyrinth) -> Int :
   var count : Int = 0
   for country in c(countries(lab)) do :
      val name = key(country)
      if getAttr(lab, name, "muslim") is True :
         val govern = getAttr(lab, name, "govern")
         if govern is String :
            if govern == "poor" or govern == "islamrule":
               count = count + 1
   count

defn getTroopLevel (lab : Labyrinth) -> String :
   label<String> return :
   if trooptrack(lab) >= 10:
      return("low")
   else if trooptrack(lab) >= 5:
      return("war")
   else:
      return("overstretch")

defn getCellOnMap (lab : Labyrinth) -> Int:
   var cell = 0
   for country in c(countries(lab)) do :
      val name = key(country)
      val sleepercell = getAttr(lab, name, "sleepercell")
      match(sleepercell):
         (s:Int) : 
            if s > 0 : 
               cell = cell + s
         (s) : cell
      val activecell = getAttr(lab, name, "activecell")
      match(activecell):
         (a:Int) :
            if a > 0: (cell = cell + a)
         (a) : cell
   cell

defn countAwaken (lab : Labyrinth) -> Int:
   var awaken = 0
   for country in c(countries(lab)) do :
      val name = key(country)
      awaken = awaken + getAwaken(lab, name)
   awaken

defn countReact (lab : Labyrinth) -> Int:
   var react = 0
   for country in c(countries(lab)) do :
      val name = key(country) 
      react = react + getReact(lab, name)
   react

defn getAwaken (lab : Labyrinth, name : String) -> Int:
   val awaken = getAttr(lab, name, "awaken")
   match(awaken) :
      (awaken : Int) : awaken
      (awaken) : 0
   
defn getReact (lab : Labyrinth, name : String) -> Int:
   val react = getAttr(lab, name, "react")
   match(react) :
      (react : Int) : react
      (react) : 0

defn shuffleDeck (lab : Labyrinth) :
   val newdeck = Vector<Int>()
   if decks(lab) is-not False :
      for d in decks(lab) as Tuple<Tuple<Int>> do:
         val d-v = to-vector<Int>(d)
         while length(d-v) > 0 :
            var index = rand(length(d-v))
            val card = get(d-v, index)
            remove(d-v, index)
            add(newdeck, card)
      clear(deck(lab))
      add-all(deck(lab), loadedDeck(lab))
      add-all(deck(lab), newdeck)

defn dealHands (lab : Labyrinth) :
   var reshuffled = false
   val [j, u] = getCardDraw(lab)
   var toJihadist : Int = j as Int
   var toUS : Int = u as Int
   while toJihadist > 0 or toUS > 0:
      if toJihadist > 0:
            reshuffled = reshuffled or drawOneCard(lab, "jihadist")
            toJihadist = toJihadist - 1
      if toUS > 0:
            reshuffled = reshuffled or drawOneCard(lab, "us")
            toUS = toUS - 1
   gprintln("JihadistHand=%_" % [jihadisthand(lab)])
   gprintln("USHand=%_" % [ushand(lab)])
   gprintln("Deck=%_" % [deck(lab)])
   gprintln("NumberOfDecks=%_" % [nbDeck(lab)])
   reshuffled

defn getCardDraw (lab : Labyrinth) :
   var toUS = 9
   var toJihadist = 9
   switch { getTroopLevel(lab) == _ } :
      "low" : toUS = 9
      "war" : toUS = 8
      else  : toUS = 7
   switch { funding(lab) <= _ } :
      3 : toJihadist = 7
      6 : toJihadist = 8
      else : toJihadist = 9
   if contains?(lapsing(lab), 273) :
      gprintln("US draws two more cards")
      toUS = toUS + 2
   [toJihadist, toUS]

defn drawOneCard (lab : Labyrinth, player : String) :
   label<True|False> return:
      var reshuffled = false
      if length(deck(lab)) == 0:
         reshuffleDeck(lab)
         reshuffled = true
         set-reshuffled(lab, true)
      if length(deck(lab)) == 0:
         gprintln("No cards in Deck")
         return(true)
      val card = deck(lab)[0]
      remove(deck(lab), 0)
      if not awakening(lab) and scenario(lab) == "Surge" and card > 120:
         set-awakening(lab, true)
         setAttr(lab, "syria", "sunni", false)
         c(countries(lab))["mali"] = awakenBoard["mali"]
         c(countries(lab))["nigeria"] = awakenBoard["nigeria"]
         for route in awakenRoutes do :
            val result = find( fn ( x : [String,String], y : [String,String] ) -> True|False : (
                                 if ( x[0] == y[0] and x[1] == y[1] ) or ( x[0] == y[1] and x[1] == y[0] ) :
                                    true
                                 else :
                                    false )
                                 routes(lab)
                                 [route] )
            match(result) : 
               (result:False) : add(routes(lab), route)
               (result) : result
         convergence(lab, "awaken")
      gprint("Card %_ is dealt to %_" % [card player])
      if player == "us":
         val original = ushand(lab)
         clear(ushand(lab))
         add(ushand(lab), card)
         add-all(ushand(lab), original)
      else:
         val original = jihadisthand(lab)
         clear(jihadisthand(lab))
         add(jihadisthand(lab), card)
         add-all(jihadisthand(lab), original)
      reshuffled

defn reshuffleDeck (lab : Labyrinth) :
   gprintln("Reshuffle Deck")
   clear(deck(lab))
   add-all(deck(lab), discard(lab))
   clear(discard(lab))
   val newdeck = Vector<Int>()
   while length(deck(lab)) > 0 :
      val index = rand(length(deck(lab)))
      val card = get(deck(lab), index)
      add(newdeck, card)
      remove(deck(lab), index)
   add-all(deck(lab), newdeck)

defn isPirates (lab : Labyrinth) -> True|False :
   if not isMarker(lab, "markers", "pirates"):
      false
   else if getGovern(lab, "somalia") == "islamrule" or getGovern(lab, "yemen") == "islamrule":
      true
   else :
      false

defn checkAutoWin (lab : Labyrinth) -> True|False :
   gprintln("Check AutoWin")
   val ir = getIslamResource(lab)
   if ir >= 6:
      gprintln("Islamic Resource=%_" % [ir])
      ; check adjacency
      if jihadistplayer(lab) == "bot":
            set-gameend(lab, true)
            set-winner(lab, "jihadist")
            set-winMethod(lab, "IR >= 6")
            true
   false

defn flipRegimeChange (lab : Labyrinth):
   for country in c(countries(lab)) do:
      val name = key(country)
      if isRegimeChange(lab, name):
            setRegimeChange(lab, name, "tan")

defn isRegimeChange (lab : Labyrinth, name : String) -> True|False:
   val color = getAttr(lab, name, "regimechange")
   match(color):
      (color:String) : true
      (color) : false

defn isGreenRegimeChange (lab : Labyrinth, name : String) -> True|False :
   val rc = getAttr(lab, name, "regimechange")
   match(rc):
      (rc : String) : true when rc == "green" else false
      (rc) : false        

defn findTrainingCamps (lab : Labyrinth) -> String|False :
   val validCountries = extract(lab, fn (x:String) : isMarker(lab, x, "trainingcamps"), false)
   if length(validCountries) == 0:
      false
   else:
      validCountries[0]

defn checkTrainingCamps (lab : Labyrinth) :
   val name = findTrainingCamps(lab)
   var newCell = 0
   match(name):
      (name : String) :
         if getCell(lab, name, true) == 0 and not isCadre(lab, name):
            removeTrainingCamps(lab, name)
         else :
            if isCaliphate(lab, name) and maxcamps(lab) == 3:
               set-maxcamps(lab, 5)
               newCell = 2
               while lesscell(lab) > 0 and newCell > 0:
                  set-lesscell(lab, lesscell(lab) - 1)
                  newCell = newCell - 1
               set-cellcamps(lab, cellcamps(lab) + newCell)
            else if not isCaliphate(lab, name) and maxcamps(lab) == 5:
               set-maxcamps(lab, 3)
               newCell = 2
               while cellcamps(lab) > 0 and newCell > 0:
                  set-cellcamps(lab, cellcamps(lab) - 1)
                  newCell = newCell - 1
               set-lesscell(lab, lesscell(lab) + newCell)
      (name) : newCell = 0

defn removeTrainingCamps (lab : Labyrinth, name : String) :
   if isMarker(lab, name, "trainingcamps"):
      val lessCell = maxcamps(lab) - cellcamps(lab)
      set-maxcamps(lab, 0)
      set-cellcamps(lab, 0)
      set-lesscell(lab, lesscell(lab) + lessCell)
      gprintln("Remove Training Camps in %_ lessCell=%_" % [name lesscell(lab)])
      removeMarker(lab, name, "trainingcamps", true)

defn countIRCountries (lab : Labyrinth) :
   var count = 0
   for country in c(countries(lab)) do:
      val name = key(country)
      if getGovern(lab, name) == "islamrule":
            count = count + 1
   count

      
; todo: implement later
defn convergence (lab : Labyrinth, who : String) -> False :
   false
   
   ; if not self.awakening:
   ;    return
   ; gprint("Convergence")
   ; gprint('Tan dr', end=' ')
   ; tan = self.rollOnce()
   ; gprint('Black dr', end=' ')
   ; black = self.rollOnce()
   ; black = (black + 1) // 2
   ; if tan == 1 and black == 3:
   ;    # special case, use table2
   ;    while True:
   ;          gprint('Use Random Muslim Country Table 2')
   ;          die = self.rollOnce()
   ;          country = self.random_muslim_country2[die - 1]
   ;          gprint(f'Rolled country={country}')
   ;          # test iraq and nigeria cases
   ;          if country == 'iraq' or country == 'nigeria':
   ;             if not self.canAwakeReact(country):
   ;                continue
   ;          break
   ; else:
   ;    # normal case
   ;    country = self.random_muslim_country[tan - 1][black - 1]
   ;    gprint(f'Rolled country={country}')
   ; # country established
   ; if not self.canAwakeReact(country):
   ;    adjCountries = self.findAdjacentCountries(country)
   ;    # remove countries not eligible
   ;    for adj in adjCountries:
   ;          if not self.canAwakeReact(adj):
   ;             adjCountries.remove(adj)
   ;    if len(adjCountries) == 0:
   ;          return
   ;    gprint(f"Random Pick from these Countries:{adjCountries}")
   ;    country = self.randomPick(adjCountries)
   ;    gprint(f'Randomly picked country={country}')
   ; # finally a valid country is found
   ; if who == 'awaken':
   ;    self.setAwaken(country, self.getAwaken(country) + 1)
   ; elif who == 'react':
   ;    self.setReact(country, self.getReact(country) + 1)
   ; gprint(self.countries[country])

defn polarization (lab : Labyrinth) -> Labyrinth :
   val a = lab
   a


defn attrition (lab : Labyrinth) -> Labyrinth:
   lab





   

   
      
